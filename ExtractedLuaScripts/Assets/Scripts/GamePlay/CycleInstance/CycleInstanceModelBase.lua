---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chenlongfa.
--- DateTime: 2024/8/5 14:10
---

local Class = require("Framework.Lua.Class")
---@class CycleInstanceModelBase
local CycleInstanceModelBase = Class("CycleInstanceModelBase")

local Execute = require("Framework.Queue.Execute")
local GameUIManager = GameTableDefine.GameUIManager
local ConfigMgr = GameTableDefine.ConfigMgr
local CycleInstanceDataManager = GameTableDefine.CycleInstanceDataManager
local ActorManager = GameTableDefine.ActorManager
local GameTimer = GameTimer
local FlyIconsUI = GameTableDefine.FlyIconsUI
local ResourceManger = GameTableDefine.ResourceManger
local ShopManager = GameTableDefine.ShopManager
local CycleInstanceDefine = require("GamePlay.CycleInstance.CycleInstanceDefine")
local GameTimeManager = GameTimeManager

local Input = CS.UnityEngine.Input ---@type UnityEngine.Input
local KeyCode = CS.UnityEngine.KeyCode

local CoinFieldName = "m_CurInstanceCoin" ---存档中副本钞票存款名
local ScoreFieldName = "m_CurScore" ---存档中副本积分名
local SCENE_CLASS_PATH = "GamePlay.CycleInstance.CycleInstanceSceneBase"

---@class CycleInstanceSaveDataBase
---@field m_RoomData table<string,CycleInstanceRoomSaveData>
---@field m_Instance_id number
---@field m_playedOpeningTimeLine boolean
---@field m_cyInstanceGiftsConfigs table[]
---@field m_cyInstanceRankAwardConfigs table[]
local CycleInstanceSaveDataBase = {}

---@class CycleInstanceRoomSaveData
---@field isUpgrading boolean -正在升级中
---@field completeTime number -升级结束时间戳
---@field level number -当前房间等级
---@field needShowUpgradeAnim boolean -是否需要播放升级完成表现
---@field upgradeNodeFurID number -升级后需要播放动画的装饰家具ID
local CycleInstanceRoomSaveData = {}

---@class InstanceTimeData
---@field Hour number
---@field Min number
---@field Sec number
local InstanceTimeData = {}

function CycleInstanceModelBase:ctor()

    self.instance_id = nil   ---副本ID(类型ID, 不是实例ID)

    -- config
    self.config_global = nil  ---对应instance_id的config全局表数据
    self.furnitureConfig = nil ---设备配置数据
    self.furnitureLevelConfig_furID = nil ---根据furniturID保存家具等级表,避免大量遍历的消耗
    self.resourceConfig = nil ---产出资源配置数据
    self.config_cy_instance_roomsLevel = nil ---房间等级配置
    self.roomsConfig = nil

    self.saveData = nil ---@type CycleInstanceSaveDataBase
    self.m_currentScene = nil ---@type CycleInstanceSceneBase
    self.roomsData = {}    ---所有房间存档数据
    self.productions = {}  ---产品存量列表
    ---
    self.m_sceneClassPath = SCENE_CLASS_PATH
    self.timer = nil ---副本时间计时器,每秒更新一次
    self.lastTime = nil ---上一秒的副本时间
    self.m_instanceTimeData = {} ---@type InstanceTimeData
    self.m_cachedTimeNowInSecond = GameTimeManager:GetCurLocalTime(true) ---@type number 当前缓存的时间,单位为秒
    self.m_isDebugMode = false
end

function CycleInstanceModelBase:Init(saveData)
    if not saveData or next(saveData) == nil then
        printf("初始化了一个不存在的循环副本")
        return
    end
    CycleInstanceModelBase.saveData = saveData
    self.instance_id = tonumber(saveData.m_Instance_id)
    self:InitConfigData()
    Execute:Async({function()
        GameUIManager:SetFloatUILockScale(true, 18)
    end})

    self:InitRoomData()

    self.lastTime = self:GetCurInstanceTime(self.instance_id)
    self.m_isDebugMode = GameConfig:IsDebugMode()
end

function CycleInstanceModelBase:OnEnter()

end

function CycleInstanceModelBase:Update(dt)

    if CycleInstanceDataManager:GetInstanceIsActive() then

        self:CalculateInstanceOnlineReward(dt)

        if self.m_currentScene then
            self.m_currentScene:Update(dt)
        end
    end

    ActorManager:Update(dt)

    if self.m_isDebugMode then
        if GameDeviceManager:IsiOSDevice() then

        elseif GameDeviceManager:IsAndroidDevice() then

        else
            if Input.GetMouseButtonDown(2) then
                GameTableDefine.CheatUI:GetView()
            end

            if Input.GetKeyDown(KeyCode.Z) then
                --self:CalculateOfflineRewards(7200, false, true)
                self:CreateClient()
            end
        end
    end
    self.m_cachedTimeNowInSecond = GameTimeManager:GetCurLocalTime(true)
end

---获取当前缓存的时间
function CycleInstanceModelBase:GetCachedTimeInSecond()
    return self.m_cachedTimeNowInSecond
end

function CycleInstanceModelBase:OnExit()
    if self.m_currentScene then
        self.m_currentScene:OnExit()
        self:DisableTimeTimer()
        self.m_currentScene = nil
    end
end

---virtual 游戏暂停，调用离线保存时间，退出副本和在副本中切换app到后台
function CycleInstanceModelBase:OnPause()
end

---virtual 游戏恢复，调用离线的计算，主要用于在副本中切到app后台
function CycleInstanceModelBase:OnResume()
end

CycleInstanceModelBase.ConfigDefine = {
    config_global = function(instance_id)
        return ConfigMgr.config_cycle_instance_global[instance_id]
    end,
    roomsConfig = function(instance_id)
        return ConfigMgr.config_cy_instance_rooms[instance_id]
    end,
    furnitureConfig = function(instance_id)
        return ConfigMgr.config_cy_instance_fur[instance_id]
    end,
    furnitureLevelConfig = function(instance_id)
        return ConfigMgr["config_cy_instance_furlevel_"..instance_id]
    end,
    furnitureLevelConfig_furID = function(instance_id)
        --GameTools:AddTimePoint("furnitureLevelConfig_furID")
        local furLevelByIDTable = {}
        local furLevelConfigs = ConfigMgr["config_cy_instance_furlevel_"..instance_id]
        do
            for furnitureLevelID,furLevelConfig in pairs(furLevelConfigs) do
                local furnitureID = furLevelConfig.furniture_id
                local furConfigs = furLevelByIDTable[furnitureID]
                if not furConfigs then
                    furConfigs = {}
                    furLevelByIDTable[furnitureID] = furConfigs
                end
                table.insert(furConfigs,furLevelConfig)
            end
        end
        do
            for furnitureID,furConfigs in pairs(furLevelByIDTable) do
                table.sort(furConfigs,function(a, b)
                    return a.level<b.level
                end)
            end
        end
        --local furLevelByIDTable = ConfigMgr.config_cy_instance_furlevel_byID
        --GameTools:CalcTimePointCost("furnitureLevelConfig_furID")
        return furLevelByIDTable
    end,
    resourceConfig = function(instance_id)
        return ConfigMgr.config_cy_instance_res[instance_id]
    end,
    giftsConfig = function(instance_id)
        local configsStr = CycleInstanceDataManager:GetCurrentModel().saveData.m_cyInstanceGiftsConfigs
        if configsStr then
            local loadFunc,err = load(configsStr)
            if loadFunc then
                local giftsConfigs = loadFunc()
                return giftsConfigs
            else
                printError("读取giftsConfig失败"..(err or ""))
                return ConfigMgr["config_cy_instance_gifts_"..instance_id]
            end
        else
            return ConfigMgr["config_cy_instance_gifts_"..instance_id]
        end
    end,
    --giftsConfigByShopID = function(instance_id)
    --    local configByIDTable = {}
    --    local giftsConfigs = ConfigMgr["config_cy_instance_gifts_"..instance_id]
    --    do
    --        for giftID,giftConfig in pairs(giftsConfigs) do
    --            configByIDTable[giftConfig.price_shop_id] = giftConfig
    --        end
    --    end
    --    return configByIDTable
    --end,

    config_shop_frame_instance = function(instance_id)
        return ConfigMgr.config_shop_frame_instance[instance_id]
    end,
    config_achievement_instance = function(instance_id)
        return ConfigMgr.config_achievement_instance[instance_id]
    end,
    config_cy_instance_reward = function(instance_id)
        local currentModel = CycleInstanceDataManager:GetCurrentModel()
        return currentModel:HaveRemoteAwardConfig() and currentModel:GetRemoteAwardConfig() or ConfigMgr.config_cy_instance_reward[instance_id]
    end,
    config_cy_instance_shop = function(instance_id)
        return ConfigMgr.config_cy_instance_shop[instance_id]
    end,
    config_instance_bind = function(instance_id)
        return ConfigMgr.config_instance_bind[instance_id]
    end,
    config_cy_instance_roomsLevel = function(instance_id)
        return ConfigMgr.config_cy_instance_roomsLevel[instance_id]
    end,
    config_cy_instance_blueprint = function(instance_id)
        return ConfigMgr.config_cy_instance_blueprint[instance_id]
    end,
    config_cy_blueprint_res = function(instance_id)
        return ConfigMgr.config_cy_blueprint_res[instance_id]
    end,
    config_cy_instance_piggypack = function(instance_id)
        return ConfigMgr.config_cy_instance_piggypack[instance_id]
    end,
    config_cy_instance_rank_reward = function(instance_id)
        --return CycleInstanceModelBase.saveData.m_cyInstanceRankAwardConfigs and CycleInstanceModelBase.saveData.m_cyInstanceRankAwardConfigs[instance_id] or {}
        local configsStr = CycleInstanceDataManager:GetCurrentModel().saveData.m_cyInstanceRankAwardConfigs
        if configsStr then
            local loadFunc,err = load(configsStr)
            if loadFunc then
                local rankAwardConfigs = loadFunc()
                return rankAwardConfigs[instance_id] or {}
            else
                --printError("解析，服务器排行榜奖励失败"..(err or ""))
                return ConfigMgr.config_cy_instance_rank_reward[instance_id]
            end
        else
            --printError("读取，服务器排行榜奖励失败"..(err or ""))
            return ConfigMgr.config_cy_instance_rank_reward[instance_id]
        end
    end,
}

function CycleInstanceModelBase:InitConfigData()

    local originIndex = getmetatable(self).__index

    setmetatable(self,{
        __index = function(cyInstanceModel,key)
            if originIndex then
                local value = originIndex[key]
                if value then
                    return value
                end
            end
            local getConfigFunc = CycleInstanceModelBase.ConfigDefine[key]
            if getConfigFunc then
                cyInstanceModel[key] = getConfigFunc(cyInstanceModel.instance_id)
                return cyInstanceModel[key]
            else
                return nil
            end
        end
    })

    --self.config_global = ConfigMgr.config_cycle_instance_global[self.instance_id]
    --
    --self.roomsConfig = ConfigMgr.config_cy_instance_rooms[self.instance_id]
    --self.furnitureConfig = ConfigMgr.config_cy_instance_fur[self.instance_id]
    --self.furnitureLevelConfig = ConfigMgr.config_cy_instance_furlevel[self.instance_id]
    --self.furnitureLevelConfig_furID = ConfigMgr.config_cy_instance_furlevel_byID
    --self.resourceConfig = ConfigMgr.config_cy_instance_res[self.instance_id]
    --self.giftsConfig = ConfigMgr.config_cy_instance_gifts[self.instance_id]
    --self.giftsConfigByShopID = ConfigMgr.config_cy_instance_gifts_byShopID[self.instance_id]
    ----
    --self.config_shop_frame_instance = ConfigMgr.config_shop_frame_instance[self.instance_id]
    --self.config_achievement_instance = ConfigMgr.config_achievement_instance[self.instance_id]
    --self.config_cy_instance_reward = ConfigMgr.config_cy_instance_reward[self.instance_id]
    --self.config_cy_instance_shop = ConfigMgr.config_cy_instance_shop[self.instance_id] or {}
    --self.config_instance_bind = ConfigMgr.config_instance_bind[self.instance_id] or {}
    --self.config_cy_instance_roomsLevel = ConfigMgr.config_cy_instance_roomsLevel[self.instance_id] or {}
    --
end

--初始化房间存档数据
function CycleInstanceModelBase:InitRoomData()
    for k,v in pairs(self.roomsConfig) do
        local roomID = v.id
        local data = self:GetCurRoomData(roomID)
        if next(data) == nil then --第一次进入场景,创建存档数据结构
            local state = 0
            if v.unlock_times == 0 then
                state = 2
            end
            self:SetRoomData(roomID, 0, state, nil, 0, true)
        end
        self.roomsData[roomID] = self:GetCurRoomData(roomID)

        --初始化设备数据
        if not self.roomsData[roomID].furList or next(self.roomsData[roomID].furList) == nil then
            for i,m in pairs(v.furniture) do
                local furLevelConfig = self:GetFurlevelConfig(m.id, m.level)
                local furState = 0
                if m.level > 0 then
                    furState = 1
                end
                local name = nil
                local prefab = nil
                if furLevelConfig.isPresonFurniture then
                    name = self:GetRandomName()
                    local prefabIndex = math.random(#furLevelConfig.NPC_skin)
                    prefab = furLevelConfig.NPC_skin[prefabIndex]
                end
                local isOpen = nil
                if v.room_category == 4 then
                    isOpen = false
                end
                local furData = {
                    ["state"] = furState,
                    ["name"] = name,
                    ["prefab"] = prefab,
                    ["isOpen"] = isOpen
                }
                self:SetRoomFurnitureData(roomID,i,furLevelConfig.id,furData)
            end
        end

    end
end

---设置一个副本房间的设备存档数据,四个参数每个都必须传值,不能为nil, 要设置的设备数据表,将要要设置的值都放在这里面用"attrName"= xxx,的这种形式设置
function CycleInstanceModelBase:SetRoomFurnitureData(roomID, index, levelID, furnitureData)

    if not roomID then
        return
    end
    local roomIDStr = tostring(roomID)
    local roomData = nil
    if self.saveData and self.saveData.m_RoomData and self.saveData.m_RoomData[roomIDStr] then
        roomData = self.saveData.m_RoomData[roomIDStr]
    else
        return
    end
    if not roomID or not index or not levelID or not furnitureData or next(furnitureData) == nil then
        return
    end

    roomData.furList = roomData.furList or {}
    local indexStr = tostring(index)
    roomData.furList[indexStr] = roomData.furList[indexStr] or {}
    roomData.furList[indexStr].index = index
    roomData.furList[indexStr].id = levelID

    for k,v in pairs(furnitureData) do
        if k == "state" then
            roomData.furList[indexStr].state = v

        elseif k == "name" then
            roomData.furList[indexStr].worker = roomData.furList[indexStr].worker or {}
            roomData.furList[indexStr].worker.name = v
        elseif  k == "prefab" then
            roomData.furList[indexStr].worker = roomData.furList[indexStr].worker or {}
            roomData.furList[indexStr].worker.prefab = roomData.furList[indexStr].worker.prefab or {}
            table.insert(roomData.furList[indexStr].worker.prefab,v)
        elseif k == "isOpen" then
            roomData.furList[indexStr].isOpen = v

        elseif k == "lastReachTime" then
            roomData.furList[indexStr].lastReachTime = v

        elseif k == "lastLeaveTime" then
            roomData.furList[indexStr].lastLeaveTime = v
        end
    end
end

---返回制定房间的数据，table中的数据结构
---@return CycleInstanceRoomSaveData
function CycleInstanceModelBase:GetCurRoomData(roomID)
    local key = tostring(roomID)
    if self.saveData and self.saveData.m_RoomData and self.saveData.m_RoomData[key] then
        return self.saveData.m_RoomData[key]
    end
    return {}
end

---从config_character_name获取随机工人名称
---@return string
function CycleInstanceModelBase:GetRandomName()
    local configName = ConfigMgr.config_character_name
    local name = {
        [1] = math.random(1, #configName.first),
        [2] = math.random(1, #configName.second)
    }
    return name
end

---根据设备ID获取furConfig
function CycleInstanceModelBase:GetFurConfigByID(furID)
    local furConfig = self.furnitureConfig[furID]
    if not furConfig then
        printError("找不到配置config_cy_instance_fur,id = "..furID)
    end
    return furConfig
end

---根据设备ID和设备等级获取furLevelConfig
function CycleInstanceModelBase:GetFurlevelConfig(furID,level)
    if level == 0 then
        level = 1
    end
    local configs = self.furnitureLevelConfig_furID[furID]
    if configs and configs[level] then
        return configs[level]
    else
        printf("未找到furID为:" .. furID .. " level:" .. level .. "对应的fueLevel配置")
    end
end

---根据设备ID获取furLevelConfig
function CycleInstanceModelBase:GetFurLevelConfigByLevelID(furLevelID)
    return self.furnitureLevelConfig[furLevelID]
end

function CycleInstanceModelBase:GetFurlevelConfigByRoomFurIndex(roomID,index)
    local furLevelID = self.roomsData[roomID].furList[tostring(index)].id
    return self:GetFurLevelConfigByLevelID(furLevelID)
end

---获取一个家具(餐桌/床)座位的数量
function CycleInstanceModelBase:GetAllFurSeatCount(furnitureID)
    return self.furnitureConfig[furnitureID].seat
end

---设置一个副本房间的存档数据,不设置的参数传nil(不含设备列表数据)
function CycleInstanceModelBase:SetRoomData(roomID, buildTimePoint, state, lastSettlementTime, worker)
    if not roomID then
        return
    end
    local roomData = nil
    local roomIDStr = tostring(roomID)
    if not self.saveData.m_RoomData then
        self.saveData.m_RoomData = {}
    end
    if not self.saveData.m_RoomData[roomIDStr] then
        self.saveData.m_RoomData[roomIDStr] = {}
    end
    roomData = self.saveData.m_RoomData[roomIDStr]
    roomData.roomID = roomID
    roomData.buildTimePoint = buildTimePoint or self.saveData.m_RoomData[roomIDStr].buildTimePoint
    roomData.state = state or self.saveData.m_RoomData[roomIDStr].state
    roomData.lastSettlementTime = lastSettlementTime or self.saveData.m_RoomData[roomIDStr].lastSettlementTime
    if self.roomsConfig[roomID].room_category == 1 then
        if not roomData.level then
            roomData.level = 1
        end
        if worker then
            roomData.worker = worker
        end
    end

    -- 1号房间播7-1，2号房间播7-3，后续都播7-2
    if roomID == 1045 and state == 2 then
        self.m_currentScene:PlayBGM()
    end

    if roomID == 1046 and state == 2 then
        self.m_currentScene:PlayBGM()
    end
end

---初始化对应场景
function CycleInstanceModelBase:InitScene()
    --初始化场景
    self.m_currentScene = require(self.m_sceneClassPath).new()
    self.m_currentScene:InitScene(self)
    self.m_currentScene:OnEnter()
    self:EnableTimeTimer()
end

--开启副本内时间计算
function CycleInstanceModelBase:EnableTimeTimer()
    if self.timer then
        GameTimer:StopTimer(self.timer)
        self.timer = nil
    end

    --创建Timer,更新副本时间并发送事件
    self.timer = GameTimer:CreateNewTimer(1, handler(self,self.OnUpdateTime), true,true)
end

---副本时间改变时调用,每秒调用一次,子类与时间相关的计算只需实现此方法
function CycleInstanceModelBase:OnUpdateTime()
    --副本结束会立即停止计时
    if not CycleInstanceDataManager:GetInstanceIsActive(self.instance_id) then
        GameTimer:StopTimer(self.timer)
        self.timer = nil
        return
    end
end

--关闭副本内时间计算
function CycleInstanceModelBase:DisableTimeTimer()
    if self.timer then
        GameTimer:StopTimer(self.timer)
        self.timer = nil
    end
end

function CycleInstanceModelBase:GetMaxAchievementLevel()
    return Tools:GetTableSize(self.config_cy_instance_reward)
end

---增加积分,自动处理越界情况
function CycleInstanceModelBase:AddScore(num)
    if BigNumber:CompareBig(num,0) then
        local isMaxLevel = false
        local curAchievement = self:GetCurInstanceKSLevel()
        local nextLevel = curAchievement + 1

        if curAchievement == #self.config_cy_instance_reward then
            isMaxLevel = true
            return
        end
        if isMaxLevel then
            nextLevel = curAchievement
        end
        local curAchiCfg = self.config_cy_instance_reward[nextLevel]
        local currentAchi = self:GetCurInstanceScore()
        local addedAchi = BigNumber:Add(currentAchi,num)
        if not BigNumber:CompareBig(curAchiCfg.experience,addedAchi)then
            if isMaxLevel then
                self:SetCurInstanceScore(curAchiCfg.experience)
                --CycleCastleMainViewUI:PlayMilestoneAnim()
                --return
            else
                self:SetCurInstanceKSLevel(nextLevel)
                --self:SetCurInstanceScore(0)
                self:SetCurInstanceScore(curAchiCfg.experience)
                local remainder = BigNumber:Subtract( addedAchi,curAchiCfg.experience)
                self:AddScore(remainder)
            end
        else
            self:SetCurInstanceScore(addedAchi)
            --CycleCastleMainViewUI:PlayMilestoneAnim()
            --return
        end
    end
end

---virtual 计算在线收益
function CycleInstanceModelBase:CalculateInstanceOnlineReward(dt)

end

---获取房间工作CD
function CycleInstanceModelBase:GetRoomCD(roomID)
    local cd = self.roomsConfig[roomID].bastCD
    local reduce = 0
    return cd - reduce
end

---房间是否解锁
function CycleInstanceModelBase:RoomIsUnlock(roomID)
    if not roomID or roomID == 0 then
        return true
    end
    local roomData = self.roomsData[roomID]
    return roomData.state > 1
end

---获取房间等级
function CycleInstanceModelBase:GetRoomLevel(roomID)
    local roomData = self.roomsData[roomID]
    return roomData.level or 1
end

---获取房间最大等级
function CycleInstanceModelBase:GetRoomMaxLevel(roomID)
    local roomLevelConfigs = self.config_cy_instance_roomsLevel[roomID]
    if not roomLevelConfigs then
        return 0
    end
    local maxLevel = 0
    for i,v in ipairs(self.config_cy_instance_roomsLevel[roomID]) do
        maxLevel = math.max(maxLevel,i)
    end
    return maxLevel
end

---获取房间等级Config
function CycleInstanceModelBase:GetRoomLevelConfig(roomID,level)
    local roomLevelConfigs = self.config_cy_instance_roomsLevel[roomID]
    if not roomLevelConfigs then
        return nil
    end
    return roomLevelConfigs[level]
end

---升级房间
function CycleInstanceModelBase:UpgradeRoom(roomID)
    local roomData = self:GetCurRoomData(roomID)
    local roomLevel = self:GetRoomLevel(roomID)
    local nextLevelConfig = self:GetRoomLevelConfig(roomID,roomLevel+1)

    --判断是否有下一级的配置
    if nextLevelConfig then
        --local requireRes = nextLevelConfig.upgrade_cost
        local requireRes = self:GetRoomUpgradeCost(roomID,roomLevel+1)
        if not BigNumber:CompareBig( requireRes,self:GetCurInstanceCoin()) then
            self:AddCurInstanceCoin("-"..requireRes)
            roomData.isUpgrading = true
            roomData.completeTime = GameTimeManager:GetCurrentServerTime() + nextLevelConfig.upgrade_time
            --及时关闭升级中的气泡
            local room = self:GetScene():GetRoomByID(roomID)
            room:HideBubble(CycleInstanceDefine.BubbleType.CanUpgrade)
            room:ShowBubble(CycleInstanceDefine.BubbleType.IsUpgrading)
            room:ShowRoom() --刷新房间vfx_upgrade
            return CycleInstanceDefine.RoomUpgradeResult.Success,nextLevelConfig
        else
            return CycleInstanceDefine.RoomUpgradeResult.ResNotEnough,nil
        end
    end
    return CycleInstanceDefine.RoomUpgradeResult.LevelMax,nil
end

---房间升级倒计时结束，应用房间升级结果
function CycleInstanceModelBase:UpgradeRoomComplete(roomID)
    local roomData = self:GetCurRoomData(roomID)
    if not roomData or not roomData.isUpgrading then
        return false
    end
    local roomLevel = self:GetRoomLevel(roomID)
    local nextLevelConfig = self:GetRoomLevelConfig(roomID,roomLevel+1)

    --判断是否有下一级的配置
    if nextLevelConfig then
        roomData.level = roomLevel + 1
        roomData.isUpgrading = false
        local furIsChange,furID = self:RoomDecorationDifferentByLevel(roomID,roomLevel,roomLevel+1)
        roomData.needShowUpgradeAnim,roomData.upgradeNodeFurID = true,furID
        return true
    else
        return false
    end
end

---virtual 播放房间升级动画
function CycleInstanceModelBase:DoRoomUpgradeAnim(roomID)
    local roomData = self:GetCurRoomData(roomID)
    if not roomData or not roomData.needShowUpgradeAnim then
        return false
    end
    self.m_currentScene.Rooms[roomID]:RefreshAllDecorationFurPrefab()
    roomData.needShowUpgradeAnim = false

    local room = self:GetScene():GetRoomByID(roomID)
    room:ShowRoom() --刷新房间vfx_upgrade
    return true
end

---两个房间等级是否装饰家具有变化
---@return boolean,number 是否有变化，有变化的ID
function CycleInstanceModelBase:RoomDecorationDifferentByLevel(roomID,level1,level2)
    local roomNextLevelCfg = self:GetRoomLevelConfig(roomID,level2)
    local roomCurrLevelCfg = self:GetRoomLevelConfig(roomID,level1)

    local nextFurIDs = roomNextLevelCfg.unlock_furID
    local currFurIDs = roomCurrLevelCfg.unlock_furID
    if not currFurIDs then
        if not nextFurIDs then
            return false
        else
            return true,nextFurIDs[1]
        end
    else
        if not nextFurIDs then
            return true,nil --反而升级没有装饰家具了,应该不可能是这个结果
        else
            if #currFurIDs ~= #nextFurIDs then
                return true,nextFurIDs[#nextFurIDs]
            else
                for i = 1, #currFurIDs do
                    if currFurIDs[i] ~= nextFurIDs[i] then
                        return true,nextFurIDs[i]
                    end
                end
                return false
            end
        end
    end
end

---根据roomID返回roomCfg
function CycleInstanceModelBase:GetRoomConfigByID(roomID)
    return self.roomsConfig[roomID] or nil
end

---获取房间解锁时间点
function CycleInstanceModelBase:GetRoomUnlockTime(roomID)
    local roomData = self.roomsData[roomID]
    local unlockNeedTime = self.roomsConfig[roomID].unlock_times
    if roomData then
        local result = roomData.buildTimePoint + unlockNeedTime
        return result
    else
        return 0
    end
end

--自动关门
function CycleInstanceModelBase:MakeDoorTimer(doorObj, cb)
    self.doorTimer = self.doorTimer or {}
    if self.doorTimer[doorObj] then
        return
        --GameTimer:StopTimer(self.doorTimer[doorObj])
    end

    self.doorTimer[doorObj] = GameTimer:CreateNewTimer(2, function()
        local closeSuccess = true
        if cb then
            closeSuccess = cb()
        end

        self.doorTimer[doorObj] = nil
        if closeSuccess == 1 then--换场景之类的,没有了动画资源
            return
        end
        if not closeSuccess then
            self:MakeDoorTimer(doorObj, cb)
        end
    end)
end

---返货当前副本中的货币
function CycleInstanceModelBase:GetCurInstanceCoin()
    if self.saveData then
        return LocalDataManager:DecryptField(self.saveData, CoinFieldName)
    end

    return 0
end

---增加当前副本金钱
function CycleInstanceModelBase:AddCurInstanceCoin(num,showFlyIcon)
    local coin = LocalDataManager:DecryptField(self.saveData, CoinFieldName)
    --coin = math.max(0, coin + num)
    coin = BigNumber:Add(coin,num)
    if BigNumber:CompareBig(0,coin) then
        coin = "0"
    end
    LocalDataManager:EncryptField(self.saveData, CoinFieldName, coin)
    self.saveData.m_CurInstanceCoin_Show = BigNumber:FormatBigNumber(coin)

    self:AddAccumulateCoin(num)

    if showFlyIcon and BigNumber:CompareBig(num,0) then
        FlyIconsUI:SetCycleInstanceNum({{itemType = 31,str = num}})
    end

    --CycleIslandMainViewUI:Refresh()
    --CycleIslandBuildingUI:RefreshView()
end

function CycleInstanceModelBase:GetCurInstanceCoinShow()
    if self.saveData then
        return self.saveData.m_CurInstanceCoin_Show or 0
    end

    return 0
end

---增加积累副本金钱
function CycleInstanceModelBase:AddAccumulateCoin(num)
    if BigNumber:CompareBig(num,0) then
        local current = self:GetAccumulateCoin()
        self.saveData.m_AccumulateCoin = BigNumber:Add(current,num)
    end
end

---@return number 累计获取的货币
function CycleInstanceModelBase:GetAccumulateCoin()
    if self.saveData and self.saveData.m_AccumulateCoin then
        return self.saveData.m_AccumulateCoin
    end
    return 0
end

---@return number 获取当前副本的时间，H:M:S
function CycleInstanceModelBase:GetCurInstanceTime()
    --副本中的开始时间globalData.instance_initial_time对应副本的starttime
    --副本的时间流逝频率globalData.instance_duration
    --已流逝时间真实时间
    if not self.m_InstanceTimeScale then
        self.m_InstanceTimeScale = (24 * 60) / self.config_global.cycle_instance_duration
    end
    local result = self.m_instanceTimeData
    result.Hour = 0
    result.Min = 0
    result.Sec = 0
    local saveData = self.saveData
    if saveData and saveData.m_StartTime and GameTimeManager:GetCurServerOrLocalTime() > saveData.m_StartTime then
        local DupOfftime = (GameTimeManager:GetSocketTime() - saveData.m_StartTime) * self.m_InstanceTimeScale
        DupOfftime = DupOfftime + 3600 * self.config_global.cycle_instance_initial_time

        result.Min = math.floor(DupOfftime % 86400 % 3600 / 60)
        result.Hour = math.floor(DupOfftime % 86400 / 3600)
    end
    return result
end

---改变副本当前时间,正数为时间向后,负数为时间向前
function CycleInstanceModelBase:ChangeCurrentTime(value)
    local saveData = self.saveData
    if saveData and saveData.m_StartTime then
        local now = GameTimeManager:GetCurrentServerTime(true)
        local changeTime = 60 * ConfigMgr.config_global.instance_duration / 24 * value
        if saveData.m_StartTime - changeTime > now then
            saveData.m_StartTime = now
        else
            saveData.m_StartTime = saveData.m_StartTime - changeTime
        end
    end
end

function CycleInstanceModelBase:IsDay()
    local timeNode = self.config_global.cycle_instance_timenode
    local currentTime = self:GetCurInstanceTime()
    if currentTime.Hour >= tonumber(timeNode[1]) and currentTime.Hour < tonumber(timeNode[2]) then
        return true
    end
    return false
end

---是否购买某设施 当前等级是多少
---@return number
function CycleInstanceModelBase:IsBuyFurnitureLevelAndCount(furnitureID, roomID)
    if not GameStateManager:IsCycleInstanceState() then
        return 0
    end
    local curLevel = 0
    local baseFurName = self:GetFurConfigByID(furnitureID).name
    local roomData = self:GetCurRoomData(roomID)
    if roomData.furList and next(roomData.furList) ~= nil then
        for i,m in pairs(roomData.furList) do
            local furLevelConfig = self:GetFurLevelConfigByLevelID(m.id)
            local furName = self:GetFurConfigByID(furLevelConfig.furniture_id).name
            --判断是否是同名设施
            if furName == baseFurName and m.state == 1 then
                curLevel = furLevelConfig.level
            end
        end
    end
    return curLevel
end

function CycleInstanceModelBase:GetRoomDataByID(roomID)
    return self.roomsData[tonumber(roomID)]
end

---副本结算后标记为每有奖励，用来判断是否显示副本按钮和副本结算界面
function CycleInstanceModelBase:SetNoRewardFlag(instance_id)
    instance_id = instance_id or self.config_instance_bind.id
    instance_id = tostring(instance_id)
    local saveData = self.saveData[instance_id]
    if saveData then
        saveData.m_IsGetCurReward = true
        LocalDataManager:WriteToFile()
    end
end

---是否显示副本入口
function CycleInstanceModelBase:CanDisplayEnterUI()
    if GameTableDefine.StarMode:GetStar() < 4 then
        return false
    end
    if not self.saveData then
        return false
    end
    if CycleInstanceDataManager:GetInstanceIsActive(self.instance_id) or
            CycleInstanceDataManager:GetInstanceRewardIsActive(self.instance_id) then
        if not GameTableDefine.FloorMode:IsInOffice() or
                GameUIManager:IsUIOpen(ENUM_GAME_UITYPE.CITY_MAP) or
                GameUIManager:IsUIOpen(ENUM_GAME_UITYPE.EUROPE_MAP_UI) then
            return false
        end
        if GameTableDefine.GameUIManager:IsUIOpen(ENUM_GAME_UITYPE.FRAGMENT_ACTIVITY_UI) or
                GameUIManager:IsUIOpen(ENUM_GAME_UITYPE.ACCUMULATED_CHARGE_UI) or
                GameUIManager:IsUIOpen(ENUM_GAME_UITYPE.LIMIT_PACK_UI) then
            return false
        end
        local now = GameTimeManager:GetCurrentServerTime()
        if not self.saveData.m_CurEnterTime or self.saveData.m_CurEnterTime == 0 then
            self.saveData.m_CurEnterTime = now
            LocalDataManager:WriteToFile()
            return true
        end

        local today = os.date("%d", now)
        local last = os.date("%d", self.saveData.m_CurEnterTime)

        if last then
            return false 
        end
        if today ~= last then
            self.saveData.m_CurEnterTime = now
            return true
        end
    end
    return false
end

---获取房间GameObject
function CycleInstanceModelBase:GetRoomGameObjectByID(roomID)
    return self.m_currentScene:GetRoomGameObjectByID(roomID)
end


---最高生产房间存档
function CycleInstanceModelBase:GetHighestLevelUnlockedBuildingData()
    if self.saveData then
        local curID = nil
        for k, v in pairs(self.saveData.m_RoomData) do
            local roomConfig = self:GetRoomConfigByID(v.roomID)
            if v.state == 2 and roomConfig.room_category == 1 then
                curID = not curID and v.roomID or (curID < v.roomID and v.roomID or curID)
            end
        end
        return self:GetRoomDataByID(curID)
    end

    return nil
end


---购买房间
function CycleInstanceModelBase:BuyRoom(roomID)
    --设置存档信息
    local timePoint = GameTimeManager:GetCurrentServerTime(true)
    self:SetRoomData(roomID,timePoint,1)

    self.m_currentScene:RefreshRoom(roomID)
    --花钱
    local cost = tonumber(self.roomsConfig[roomID].unlock_require)
    self:AddCurInstanceCoin(-cost)
end

---检查房间是否满足解锁条件
function CycleInstanceModelBase:CheckRoomCondition(roomID)
    local roomData = self:GetCurRoomData(roomID)
    local roomConfig = self:GetRoomConfigByID(roomID)
    local money = self:GetCurInstanceCoin()
    local cost = tonumber(roomConfig.unlock_require)
    local lastRoomData = self:GetCurRoomData(roomConfig.unlock_room)
    if roomData and next(roomData) ~= nil and cost <= money and lastRoomData and lastRoomData.state and lastRoomData.state == 2 then
        return true
    else
        return false
    end
end

---virtual 购买家具
function CycleInstanceModelBase:BuyFurniture(roomID, index, furLevelID)
    local roomData = self.roomsData[roomID]
    local furData = roomData.furList[tostring(index)]
    local isNew = true
    if furData and next(furData) ~= nil then
        isNew = false
    end
    local furnitureData = {["state"] = 1 }
    --刷新工人列表
    local furLevelData = self.furnitureLevelConfig[furLevelID]
    if furLevelData.isPresonFurniture and furLevelData.level >1 then
        local preLevelData = self.furnitureLevelConfig[furLevelID-1]
        if preLevelData.worker<furLevelData.worker then
            local prefabIndex = math.random(#furLevelData.NPC_skin)
            furnitureData.prefab = furLevelData.NPC_skin[prefabIndex]
        end
    end
    --设置存档信息
    self:SetRoomFurnitureData(roomID, index, furLevelID, furnitureData)

    --刷新场景中的物体
    self.m_currentScene:RefreshRoom(roomID, index, true)

    --花钱
    local furLevelCfg = self.furnitureLevelConfig[furLevelID]
    local cost = tonumber(furLevelCfg.cost)
    self:AddCurInstanceCoin(-cost)
    --CycleCastleMainViewUI:Refresh()

    --增加升级埋点,每5级埋点一次
    if furLevelCfg.level % 10 == 0 then
        GameSDKs:TrackForeign("cy_fur_upgrade", { id = tonumber(roomID), level = tonumber(furLevelCfg.level) })
    end
    
    --显示通知
    --if furLevelCfg.level == 1 and furLevelCfg.isPresonFurniture then
    --    CycleCastleMainViewUI:CallNotify(1)
    --end
end

---根据房间类型获取房间信息
function CycleInstanceModelBase:GetRoomDataByType(type)
    local result = nil
    for k,v in pairs(self.roomsConfig) do
        if v.room_category == type  then
            if not result then
                result = {}
            end
            result[#result + 1] = self.roomsData[k]
        end
    end
    return result
end

--region 场景

---@return CycleInstanceSceneBase
function CycleInstanceModelBase:GetScene()
    return self.m_currentScene
end

function CycleInstanceModelBase:LocatePosition(position,IsShowMove,cb)
    self.m_currentScene:LocatePosition(position,IsShowMove,cb)
end

function CycleInstanceModelBase:Position3dTo2d(position)
    return self.m_currentScene:Position3dTo2d(position)
end

---刷新副本场景
function CycleInstanceModelBase:RefreshScene()
    self.m_currentScene:RefreshScene()
end

---显示选中的家具
function CycleInstanceModelBase:ShowSelectFurniture(furGO,preBuy)
    self.m_currentScene:ShowSelectFurniture(furGO,preBuy)
end

---获取家具GameObject
function CycleInstanceModelBase:GetSceneRoomFurnitureGo(roomID, furIndex, subIndex)
    return self.m_currentScene:GetSceneRoomFurnitureGo(roomID, furIndex, subIndex)
end

--TODO 和上面的函数重复了
---获取家具GameObject
function CycleInstanceModelBase:GetFurGameObject(roomID, furIndex, subIndex)
    return self.m_currentScene:GetSceneRoomFurnitureGo(roomID, furIndex, subIndex)
end

---相机看向目标对象
function CycleInstanceModelBase:LookAtSceneGO(roomID,furIndex,cameraFocus,isBack,callback)
    self.m_currentScene:LookAtSceneGO(roomID,furIndex,cameraFocus,isBack,callback)
end

--endregion

--region 里程碑

function CycleInstanceModelBase:GetMaxAchievementLevel()
    return Tools:GetTableSize(self.config_cy_instance_reward)
end

---返回当前副本的分数
function CycleInstanceModelBase:GetCurInstanceScore()
    if self.saveData then
        return LocalDataManager:DecryptField(self.saveData,ScoreFieldName)
    end
    return 0
end

---设置积分
function CycleInstanceModelBase:SetCurInstanceScore(value)
    if self.saveData then
        LocalDataManager:EncryptField(self.saveData,ScoreFieldName,value)
        self.saveData.m_CurScore_Show = BigNumber:FormatBigNumber(value)
    end
end

---获得当前里程碑
function CycleInstanceModelBase:GetCurInstanceKSLevel()
    local result = 0
    if not self.saveData.m_CurKSLevel then
        self.saveData.m_CurKSLevel = 0
    end
    result = self.saveData.m_CurKSLevel or 0

    return result
end

---virtual 设置积分等级
function CycleInstanceModelBase:SetCurInstanceKSLevel(value)
    if self.saveData then
        self.saveData.m_CurKSLevel = value
    end
end


---返回当前副本的分数
function CycleInstanceModelBase:GetCurInstanceScore()
    if self.saveData then
        return LocalDataManager:DecryptField(self.saveData,ScoreFieldName)
    end
    return 0
end

---获取当前里程碑所有没有领取的里程碑奖励
function CycleInstanceModelBase:GetAllSKRewardNotClaim()
    local resultRewards = {}
    for k, v in pairs(self.config_cy_instance_reward) do
        local isClaimed = false
        for k1, v1 in pairs(self.saveData.m_ObtainRewards or {}) do
            if v1 == v.level then
                isClaimed = true
                break
            end
        end
        -- if not isClaimed and v.level <= self:GetCurInstanceKSLevel() then
        if not isClaimed then
            local reward = self:GetRewardByLevel(v.level)
            if reward and next(reward) ~= nil then
                table.insert(resultRewards, self:GetRewardByLevel(v.level))
            end
        end
    end

    return resultRewards
end

---获得当前等级的奖励
function CycleInstanceModelBase:GetRewardByLevel(level)
    local rewards = {}
    if level > self:GetCurInstanceKSLevel() then
        return rewards
    end
    for k, v in pairs(self.config_cy_instance_reward) do
        if v.level == level then
            rewards.level = level
            rewards.shop_id = v.shop_id
            rewards.count = v.count
            break
        end
    end
    return rewards
end

function CycleInstanceModelBase:RealGetRewardByLevel(level, isNotSendCEOReard)
    if level > self:GetCurInstanceKSLevel() then
        return false
    end
    for _, v in pairs(self.saveData.m_ObtainRewards or {}) do
        if v == level then
            return false
        end
    end
    if not self.saveData.m_ObtainRewards then
        self.saveData.m_ObtainRewards = {}
    end
    for k, v in pairs(self.saveData.m_ObtainRewards) do
        if v == level then
            return false
        end
    end
    table.insert(self.saveData.m_ObtainRewards, level)
    local shopID = self.config_cy_instance_reward[level].shop_id
    local shopCfg = ConfigMgr.config_shop[shopID]
    if shopCfg.type == 3 or shopCfg.type == 4 or shopCfg.type == 29 or shopCfg.type == 42 or shopCfg.type == 43 or shopCfg.type == 44 then
        local amount = shopCfg.amount * self.config_cy_instance_reward[level].count
        if shopCfg.type == 3 then
            ResourceManger:AddDiamond(amount)
            --埋点
            GameSDKs:TrackForeign("virtual_currency", {currency_type = 1, pos = "循环副本里程碑", behaviour = 1, num_new = amount})
        elseif shopCfg.type == 4 then
			ResourceManger:AddTicket(amount)
			GameSDKs:TrackForeign("ad_ticket", {behavior = 1, num_new = amount, source = "里程碑奖励"})
        elseif shopCfg.type == 29 then
            ResourceManger:AddWheelTicket(amount)
            GameSDKs:TrackForeign("wheel_ticket", {behavior = 1, num_new = amount})
        elseif shopCfg.type == 42 and not isNotSendCEOReard then
            --CEO宝箱
            GameTableDefine.CEODataManager:OpenCEOBox(shopCfg.param[1], amount, false, function()
                if GameTableDefine.CycleNightClubMilepostUI.m_view then
                    GameTableDefine.CycleNightClubMilepostUI:Refresh()
                end
            end, 2)
        elseif shopCfg.type == 43 and not isNotSendCEOReard then
            --CEO钥匙
            GameSDKs:TrackForeign("ceo_key_change", {type = shopCfg.param[1], source = "玩具副本领取单个里程碑奖励", num = tonumber(amount)}) 
            GameTableDefine.CEODataManager:AddCEOKey(shopCfg.param[1], amount)
        elseif shopCfg.type == 44 and not isNotSendCEOReard then
            --CEO卡牌
            local lastDispRewards = {}
            for i = 1, amount do
                local ceoid = GameTableDefine.CEODataManager:GetCEOCardReward(shopCfg.param[1])
                local tmpTranDiamond = GameTableDefine.CEODataManager:NeedTransformCEOCardToDiamond(ceoid)
                if tmpTranDiamond > 0 then
                    if not lastDispRewards.diamonds then
                        lastDispRewards.diamonds = tmpTranDiamond
                    else
                        lastDispRewards.diamonds  = lastDispRewards.diamonds + tmpTranDiamond
                    end
                    --给钻石
                    GameSDKs:TrackForeign("ceo_card_change", {type = shopCfg.param[1], result = "diamond", source = "单个里程碑奖励获取"})
                    ResourceManger:AddDiamond(tmpTranDiamond)
                else
                    if not lastDispRewards.ceoids then
                        lastDispRewards.ceoids = {}
                    end
                    if not lastDispRewards.ceoids[ceoid] then
                        lastDispRewards.ceoids[ceoid] = 1
                    else
                        lastDispRewards.ceoids[ceoid]  = lastDispRewards.ceoids[ceoid] + 1
                    end
                    --给卡
                    GameSDKs:TrackForeign("ceo_card_change", {type = shopCfg.param[1], result = tostring(ceoid), source = "单个里程碑奖励获取"})
                    GameTableDefine.CEODataManager:GetCEOCardByCEOID(ceoid)
                end
            end
            lastDispRewards.shop_id = shopID
            return true, lastDispRewards
        end
    else
        --首先判断是否要转换成钻石发放
        local addDiamond = self:GetSameShopItemConverToDiamond(shopID)
        if addDiamond > 0 then
            ResourceManger:AddDiamond(addDiamond)
        end

        --小时现金
        if shopCfg.type == 9 then
            local resType = ResourceManger:GetShopCashType(shopCfg.country)
            local cashType = 2
            local countryCode = 1
            local amount = shopCfg.amount * self.config_cy_instance_reward[level].count * 3600 / 30
            local num = GameTableDefine.FloorMode:GetTotalRent() * amount
            if resType == "euro" and GameTableDefine.CityMode:CheckBuildingSatisfy(700) then
                num = GameTableDefine.FloorMode:GetTotalRent(nil, 2) * amount
                cashType = 6
                countryCode = 2
            end
            ResourceManger:Add(cashType, num, nil, nil, true)
            GameSDKs:TrackForeign("cash_event", {type_new = tonumber(countryCode), change_new = 0, amount_new = tonumber(num) or 0, position = "副本里程碑奖励"})
        else
            GameTableDefine.ShopManager:Buy(shopID, false, nil, nil)
        end
    end
    GameSDKs:TrackForeign("cy_mile_claim", { level = tonumber(level) })
    return true
end

function CycleInstanceModelBase:IsLevelRewardClaimed(level)
    local result = false
    for k, v in pairs(self.saveData.m_ObtainRewards or {}) do
        if v == level then
            return true
        end
    end
    return result
end

---获得当前未领奖的等级
function CycleInstanceModelBase:GetNotClaimedLevel()
    if self.saveData and self.saveData.m_CurKSLevel then
        for i = 1, self.saveData.m_CurKSLevel do
            if not self:IsLevelRewardClaimed(i) then
                return i
            end
        end
        return 0
    end
    return 0
end

---是否有任何奖励可以领取
function CycleInstanceModelBase:IsAnyRewardCanClaim()
    if self.saveData then
        local curLevel = self:GetCurInstanceKSLevel()
        if curLevel>0 then
            for i = 1, curLevel do
                if not self:IsLevelRewardClaimed(i) then
                    return true
                end
            end
        end
    end
    return false
end

---判断是否要转换成钻石发放
function CycleInstanceModelBase:GetSameShopItemConverToDiamond(shopId)
    local backDiamond = 0
    local currCfg = GameTableDefine.ShopManager:GetCfg(shopId)
    if currCfg and GameTableDefine.ShopManager:BoughtBefor(shopId) then
        --增加单个商品购买时判断是否转钻石
        if currCfg.type == 13 or currCfg.type == 14 then--宠物保安,配置在param2[1]
            backDiamond = backDiamond + currCfg.param2[1]
        elseif currCfg.type == 6 or currCfg.type == 7 then--npc
            backDiamond = backDiamond + currCfg.param[1]
        elseif currCfg.type == 5 then--免广告
            backDiamond = backDiamond + currCfg.param[1]
        end

    end
    return backDiamond
end

--endregion

--region 商店

---是不是当前副本最后一天了
function CycleInstanceModelBase:IsLastOneDay()
    local timeRemaining = nil
    if CycleInstanceDataManager.instanceState.isActive == CycleInstanceDataManager:GetInstanceState() then
        timeRemaining = self:GetLeftInstanceTime()
        if timeRemaining <= 3600 * 24 then
            return true
        end
    else
        return false
    end
end

---获取离开副本的时间
function CycleInstanceModelBase:GetLeftInstanceTime()
    if self.saveData.m_StartTime and self.saveData.m_EndTime and self.saveData.m_EndTime - self.saveData.m_StartTime > 0 and self.saveData.m_EndTime - GameTimeManager:GetCurServerOrLocalTime() > 0 then
        return self.saveData.m_EndTime - GameTimeManager:GetCurServerOrLocalTime()
    end
    return 0
end

---获取最后一天的打折数据
function CycleInstanceModelBase:GetLastOneDayDiscount()
    return 0
end

--endregion

--region 任务

---获取任务存档
function CycleInstanceModelBase:GetTaskSaveData()
    if self.saveData then
        local taskData = self.saveData["CycleIslandTaskData"]
        if not taskData then
            taskData = {}
            self.saveData["CycleIslandTaskData"] = taskData
        end
        return taskData
    end
    return {}
end

---增加[任务开启后]积累副本[货币]
function CycleInstanceModelBase:AddTaskAccumulateCoin(num)
    if BigNumber:CompareBig(num,0) then
        local current = self:GetTaskAccumulateCoin()
        self.saveData.m_taskAccumulateCoin = BigNumber:Add(current,num)
    end
end

---@return number 累计[任务开启后]获取的[货币]
function CycleInstanceModelBase:GetTaskAccumulateCoin()
    if self.saveData and self.saveData.m_taskAccumulateCoin then
        return self.saveData.m_taskAccumulateCoin
    end
    return 0
end

---@return number 重置[任务开启后]获取的[货币]
function CycleInstanceModelBase:ResetTaskAccumulateCoin()
    if self.saveData then
        self.saveData.m_taskAccumulateCoin = "0"
    end
end

--endregion

--region 礼包

function CycleInstanceModelBase:GetGiftCfgByID(giftIDOrShopID)
    local id = tonumber(giftIDOrShopID)
    if self.giftsConfig[id] then
        return self.giftsConfig[id]
    end
    --return self.giftsConfigByShopID[id]
end

---增加礼包已购买次数
function CycleInstanceModelBase:AddGiftPackBuyTimes(packID,times)
    if self.saveData then
        if not self.saveData.m_giftPackBuyTimes then
            self.saveData.m_giftPackBuyTimes = {}
        end
        local kPackID = tostring(packID)
        self.saveData.m_giftPackBuyTimes[kPackID] = (self.saveData.m_giftPackBuyTimes[kPackID] or 0) + times
    end
end

---礼包已购买次数
function CycleInstanceModelBase:GetGiftPackBuyTimes(packID)
    if self.saveData then
        if not self.saveData.m_giftPackBuyTimes then
            return 0
        end
        return self.saveData.m_giftPackBuyTimes[tostring(packID)] or 0
    end
    return 0
end

function CycleInstanceModelBase:CanBuyGift(packID)
    local giftCfg = self:GetGiftCfgByID(packID)
    if giftCfg.limit == 0 then
        return true
    else
        local buyTimes = self:GetGiftPackBuyTimes(packID)
        return buyTimes < giftCfg.limit
    end
end

function CycleInstanceModelBase:RemoveGift(packID)
    local giftCfg = self:GetGiftCfgByID(packID)
    if self.saveData and self.saveData.m_LimitTimePack then
        --if giftCfg.type == 1 then
        --    self.saveData.m_LimitTimePack[tostring(giftCfg.id)].removed = true
        --else
        --    self:SetGiftOpenTime(giftCfg.id, self:GetGiftOpenTime(packID) + giftCfg.time * 60)
        --end
        self.saveData.m_LimitTimePack[tostring(giftCfg.id)].removed = true
        printf("移除礼包 ".. packID)
    end
end

function CycleInstanceModelBase:InitLimitTimePack()
    if self.saveData then
        if not self.saveData.m_LimitTimePack then
            self.saveData.m_LimitTimePack = {}
        end
        for k, v in pairs(self.giftsConfig) do
            if v.type == 1 then
                self:AddLimitTimePack(k)
            end
        end
    end
end

---添加限时礼包
function CycleInstanceModelBase:AddLimitTimePack(giftsID)
    if self.saveData then
        local giftsCfg = self:GetGiftCfgByID(giftsID)
        if not self.saveData.m_LimitTimePack[tostring(giftsID)] then
            self.saveData.m_LimitTimePack[tostring(giftsID)] = {}
        end
        self.saveData.m_LimitTimePack[tostring(giftsID)].id = giftsID
        self.saveData.m_LimitTimePack[tostring(giftsID)].time = giftsCfg.type > 1 and GameTimeManager:GetCurrentServerTime(true) or nil
    end
end

function CycleInstanceModelBase:SetLimitTimePackCD(giftsID)
    if self.saveData then
        local giftsCfg = self:GetGiftCfgByID(giftsID)
        if self.saveData.m_LimitTimePack[tostring(giftsCfg.id)] and giftsCfg.type == 1 then
            local now = GameTimeManager:GetCurrentServerTime(true)
            self.saveData.m_LimitTimePack[tostring(giftsCfg.id)].time = now
        end
    end
end

---可以添加限时礼包
function CycleInstanceModelBase:CanAddLimitTimePack(giftsID)
    if self.saveData then
        local giftsCfg = self:GetGiftCfgByID(giftsID)
        if not self.saveData.m_LimitTimePack or not self.saveData.m_LimitTimePack[tostring(giftsCfg.id)] then   -- 存档中没有礼包信息可以直接加
            return true
        end
        if self.saveData.m_LimitTimePack and self.saveData.m_LimitTimePack[tostring(giftsCfg.id)] then
            local now = GameTimeManager:GetCurrentServerTime(true)

            if giftsCfg.type == 1 then -- 常驻礼包未领取过时可以直接加, 领取CD结束后可以加
                if not self.saveData.m_LimitTimePack[tostring(giftsCfg.id)].time or self.saveData.m_LimitTimePack[tostring(giftsCfg.id)].time + (giftsCfg.time + giftsCfg.cd) * 60 < now then
                    return true
                end
            end
            if giftsCfg.type == 2 and self.saveData.m_LimitTimePack[tostring(giftsCfg.id)].time + giftsCfg.cd * 60 <= now and not self.saveData.m_LimitTimePack[tostring(giftsCfg.id)].removed then    -- 限时礼包时间范围内可以加
                return true
            end
        end
    end
    return false
end

function CycleInstanceModelBase:GetLimitTimePackData(id)
    if self.saveData and self.saveData.m_LimitTimePack then
        return self.saveData.m_LimitTimePack[tostring(id)]
    end
end

function CycleInstanceModelBase:GetActivePackList()
    if self.saveData and self.saveData.m_LimitTimePack then
        local result = {}
        local temp = {}
        local now = GameTimeManager:GetCurrentServerTime(true)
        for k, v in pairs(self.saveData.m_LimitTimePack) do
            local giftsCfg = self:GetGiftCfgByID(k)
            if giftsCfg.type == 1 and (not v.removed) then
                table.insert(temp, { id = v.id })
            elseif giftsCfg.type == 2 then
                local startTime = v.time
                if startTime then
                    local endTime = startTime + giftsCfg.time * 60
                    if endTime >= now and (not v.openTime or v.openTime < endTime) and (not v.removed) and self:CanBuyGift(v.id) then
                        table.insert(temp, { id = v.id })
                    end
                else
                    printf("礼包".. v.id .. " time为空")
                end
            end

        end
        table.sort(temp,function(a, b) return a.id < b.id end)
        for i = 1, #temp do
            table.insert(result, temp[i].id)
        end
        return result
    end
end

---@return boolean
function CycleInstanceModelBase:IsAnyGiftPackIsActive()
    if self.saveData and self.saveData.m_LimitTimePack then
        local now = GameTimeManager:GetCurrentServerTime(true)
        for k, v in pairs(self.saveData.m_LimitTimePack) do
            local giftsCfg = self:GetGiftCfgByID(k)
            if giftsCfg.type == 1 and (not v.removed) then
                return true
            elseif giftsCfg.type == 2 then
                local startTime = v.time
                if startTime then
                    local endTime = startTime + giftsCfg.time * 60
                    if endTime >= now and (not v.openTime or v.openTime < endTime) and (not v.removed) and self:CanBuyGift(v.id) then
                        return true
                    end
                end
            end

        end
    end
    return false
end

function CycleInstanceModelBase:SetGiftOpenTime(packID, value)
    local giftCfg = self:GetGiftCfgByID(packID)
    if self.saveData and self.saveData.m_LimitTimePack and self.saveData.m_LimitTimePack[tostring(giftCfg.id)] then
        self.saveData.m_LimitTimePack[tostring(giftCfg.id)].openTime = value or GameTimeManager:GetCurrentServerTime(true)
    end
end

function CycleInstanceModelBase:GetGiftOpenTime(packID)
    local giftCfg = self:GetGiftCfgByID(packID) 
    if self.saveData and self.saveData.m_LimitTimePack and self.saveData.m_LimitTimePack[tostring(giftCfg.id)] then
        --if not self.saveData.m_LimitTimePack[tostring(giftCfg.id)].openTime then
        --    self:SetGiftOpenTime(giftCfg.id)
        --end
        return self.saveData.m_LimitTimePack[tostring(giftCfg.id)].openTime
    end
end


function CycleInstanceModelBase:RemoveTrigger(eventType, param)
    for k, v in pairs(self.giftsConfig) do
        if v.remove[1] == eventType then
            if eventType == 1 then
                if v.remove[2] == param then
                    self:RemoveGift(v.id)
                    break
                end
            else
                self:RemoveGift(v.id)
                break
            end
        end
    end
end



--endregion

--region 广告事件

---iaa 广告事件存档
function CycleInstanceModelBase:GetEventData()
    if self.saveData then
        if not self.saveData.m_Event then
            local now = GameTimeManager:GetCurrentServerTime(true)
            local curDay = GameTimeManager:GetTimeLengthDate(now).d
            self.saveData.m_Event = {}
            self.saveData.m_Event.day = curDay
            self.saveData.m_Event.count = 0
            self.saveData.m_Event.lastTime = 0
        end
        return self.saveData.m_Event
    end
    return nil
end

---iaa 新增广告事件计数
function CycleInstanceModelBase:AddEventTime()
    if self.saveData then
        self.saveData.m_Event = self:GetEventData()
        local now = GameTimeManager:GetCurrentServerTime(true)
        local curDay = GameTimeManager:GetTimeLengthDate(now).d
        if curDay ~= self.saveData.m_Event.day then
            self.saveData.m_Event.count = 0
            self.saveData.m_Event.day = curDay
        end
        self.saveData.m_Event.count = self.saveData.m_Event.count + 1
        self.saveData.m_Event.lastTime = now
        LocalDataManager:WriteToFile()
    end
end

function CycleInstanceModelBase:EventInstanceBack()
    self.m_currentScene:EventInstanceBack()
end

--endregion


---获取一个房间所有冷却缩减
function CycleInstanceModelBase:GetRoomCDReduce(roomID)
    local count = 0
    --local roomData = self.roomsData[roomID]
    --for k,v in pairs(roomData.furList) do
    --    if v.state == 1 then
    --        local attrSum = self:GetFurLevelCfgAttrSum(v.id, "cooltime")
    --        count = count + attrSum
    --    end
    --end
    return count
end



---是否播放初到场景的开场TimeLine
function CycleInstanceModelBase:GetIsPlayedOpeningTimeLine()
    if self.saveData then
        return self.saveData.m_playedOpeningTimeLine
    end
end
---设为已经播放初到场景的开场TimeLine
function CycleInstanceModelBase:SetIsPlayedOpeningTimeLine()
    if self.saveData then
        self.saveData.m_playedOpeningTimeLine = true
    end
end

---获取引导ID
function CycleInstanceModelBase:GetGuideID()
    if self.saveData then
        return self.saveData.m_Guide
    end
    return nil
end

function CycleInstanceModelBase:SetGuideID(value)

    if self.saveData then
        self.saveData.m_Guide = value
        LocalDataManager:WriteToFile()
    end
end

---virtual 设置引导为已完成状态
function CycleInstanceModelBase:SetGuideCompleted(guideID)
    if not self.saveData.completedGuides then
        self.saveData.completedGuides = {}
    end
    self.saveData.completedGuides[tostring(guideID)] = true
end

---返回引导是否完成
function CycleInstanceModelBase:IsGuideCompleted(guideID)
    if not self.saveData.completedGuides then
        return false
    end
    return self.saveData.completedGuides[tostring(guideID)] and true or false
end

---virtual 返回房间升级消耗的钱
function CycleInstanceModelBase:GetRoomUpgradeCost(roomID,level)
    local roomNextLevelCfg = self:GetRoomLevelConfig(roomID,level)
    if roomNextLevelCfg.upgrade_cost then
        local cost = roomNextLevelCfg.upgrade_cost
        return cost
    else
        return 0
    end
end

---virtual 离线推送
function CycleInstanceModelBase:SendNotification()

end

---virtual 奖励金钱 每分钟数额(拉霸机，广告等)
function CycleInstanceModelBase:GetRewardInComePerMinute()
    printError("请在对应副本Model类中重写此方法")
    return 0
end

function CycleInstanceModelBase:GetRemoteAwardConfig()
    return self.saveData.m_RemoveAwardData or self.config_cy_instance_reward
end

function CycleInstanceModelBase:HaveRemoteAwardConfig()
    return self.saveData.m_RemoveAwardData
end

function CycleInstanceModelBase:GetCurInstanceTag()
    return self.saveData.m_tag
end

function CycleInstanceModelBase:GetRankManager()
    return CycleInstanceDefine.InstanceClass[tonumber(self.instance_id)].Rank
end



return CycleInstanceModelBase