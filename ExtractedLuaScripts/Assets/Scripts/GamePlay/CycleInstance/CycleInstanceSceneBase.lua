---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chenlongfa.
--- DateTime: 2024/8/5 14:10
---

local Class = require("Framework.Lua.Class")
local BaseScene = require("Framework.Scene.BaseScene")
---@class CycleInstanceSceneBase:BaseScene
local CycleInstanceSceneBase = Class("CycleInstanceSceneBase",BaseScene)


local LightManager = GameTableDefine.LightManager
local GameObject = CS.UnityEngine.GameObject
local UnityHelper = CS.Common.Utils.UnityHelper
local Transform = CS.UnityEngine.Transform
local MeshRenderer = CS.UnityEngine.MeshRenderer
local GlintingManager = CS.Common.Utils.GlintingManager.Instance

local CycleInstanceDefine = require("GamePlay.CycleInstance.CycleInstanceDefine")
local InteractionsManager = require "CodeRefactoring.Interactions.InteractionsManager"
local ActorDefine = require("CodeRefactoring.Actor.ActorDefine")
local ConfigMgr = GameTableDefine.ConfigMgr
local GameTimer = GameTimer
local ActorManager = GameTableDefine.ActorManager
local GameResMgr = require("GameUtils.GameResManager")
local GameTimeManager = GameTimeManager
local CycleInstanceDataManager = GameTableDefine.CycleInstanceDataManager
local SoundEngine = GameTableDefine.SoundEngine
local EventInstance = require("CodeRefactoring.Actor.Actors.EventInstanceNew")
local EventManager = require("Framework.Event.Manager")
local FloatUI = GameTableDefine.FloatUI

local TalkUI = GameTableDefine.TalkUI
local LocalDataManager = LocalDataManager
local GameUIManager = GameTableDefine.GameUIManager
local GuideManager = GameTableDefine.GuideManager
local preBuyMatPath = "Assets/Res/Materials/FX_Materials/PreBuy.mat"

local deltaV = 0.1 -- 材质参数变化速度

function CycleInstanceSceneBase:ctor()
    self:getSuper(CycleInstanceSceneBase).ctor(self)

    self.m_instanceModel = nil ---@type CycleInstanceModelBase
    self.m_instanceRoomClass = nil
    self.roomsConfig = nil    ---房间配置数据
    self.roomsData = nil   ---所有房间存档数据
    self.personList = {}  ---@type table<number,CycleInstanceWorkerClass[]>  --所有员工实例列表
    self.Rooms = {}  ---@type CycleInstanceRoomBase[] --房间表
    self.m_personRoot = GameObject.Find("NPC").gameObject   --NPC根节点
    self.m_nightGos = nil
    self.m_dayGos = nil
    self.m_glinting = {} ---家具闪烁数据
    self.eventInstance = nil ---@type EventInstanceNew -IAA演员

    self.m_selectFurniture = nil ---被选中的家具
    self.m_lastSelectIsPrebuy = nil ---上个被选择的家具是将要买的

    self.revertMaterialData = nil ---选中家具发光的原材质配置
end

---@param model CycleInstanceModelBase
function CycleInstanceSceneBase:InitScene(model)
    self.m_instanceModel = model
    self.roomsConfig = model.roomsConfig    --房间配置数据
    self.roomsData = model.roomsData   --所有房间存档数据
    self.m_instanceRoomClass = require(CycleInstanceDefine.InstanceClass[model.instance_id].Room)

    self:InitSceneLight()
    self:InitRooms()
end

function CycleInstanceSceneBase:OnEnter()
    self:getSuper(CycleInstanceSceneBase).OnEnter(self)
    self:PlayBGM()
    self:InitEventActor()

end

function CycleInstanceSceneBase:OnExit()
    self.m_instanceModel = nil
    self.m_instanceRoomClass = nil
    self.roomsConfig = nil
    self.roomsData = nil
    self.personList = nil
    self.m_personRoot = nil
    self.m_glinting = nil
    self.m_lastSelectIsPrebuy = nil
    self.revertMaterialData = nil

    self.eventInstance:Destroy()
    self.eventInstance = nil
    self:StopBGM()
    self.m_nightGos = nil
    self.m_dayGos = nil
    self.m_selectFurniture = nil
    GlintingManager:ClearCachedData()

    for k,room in pairs(self.Rooms) do
        room:OnExit()
    end
    self.Rooms = nil

    self:getSuper(CycleInstanceSceneBase).OnExit(self,self)
    FloatUI:DestroyFloatUIView()
end

function CycleInstanceSceneBase:Update(dt)
    self:getSuper(CycleInstanceSceneBase).OnUpdate(self,self)
    self:RefreshLight()
end

function CycleInstanceSceneBase:OnPause()

end

function CycleInstanceSceneBase:OnResume()

end

---初始化场景光照
function CycleInstanceSceneBase:InitSceneLight()
    LightManager:Init()
end


function CycleInstanceSceneBase:InitRooms()
    local Environment = GameObject.Find("Environment")

    for k, v in pairs(self.roomsConfig) do
        local newRoom = self.m_instanceRoomClass.new() ---@type CycleInstanceRoomBase
        local roomGO = self:GetGo(Environment, v.object_name)
        local roomData = self.roomsData[v.id]
        self.Rooms[v.id] = newRoom
        newRoom:Init(v.room_category, roomData, v, roomGO, function(GO, roomID, index, isBuy)
            if not self.Rooms[v.id].existence then
                GameTimer:CreateNewTimer(1, function()
                    self:InitInteractionRoomData(v.id)
                end)
            else
                if self.Rooms[v.id].reTimer then
                    GameTimer:StopTimer(self.Rooms[v.id].reTimer)
                    self.Rooms[v.id].reTimer = nil
                end
                self.Rooms[v.id].reTimer = GameTimer:CreateNewTimer(1, function()
                    self.Rooms[v.id].reTimer = nil
                    self:RefreshInteractionRoomData(v.id)
                end)
            end
            self.Rooms[v.id].existence = true
            --index应该始终等于1
            local levelID = roomData.furList[tostring(index)].id
            if newRoom.furLevelConfig[levelID].isPresonFurniture then
                --是工人家具
                if not self.personList[roomID] then
                    self.personList[roomID] = {}
                end
                if not self.personList[roomID][index] then
                    self.personList[roomID][index] = {}
                end
                self:CreateWorkers(GO, roomGO,index, isBuy, v.id,self.personList[roomID][index])
            else
                --不是工人家具
                if newRoom.furLevelConfig[levelID].shipCD > 0 then   -- 船
                    local trans = GO:GetComponentsInChildren(typeof(Transform))
                    for i=0,trans.Length-1 do
                        if trans[i].gameObject.tag == "TAG_DAY_OBJ" then
                            self.m_dayGos[#self.m_dayGos + 1] = trans[i].gameObject
                        elseif trans[i].gameObject.tag == "TAG_NIGHT_OBJ" then
                            self.m_nightGos[#self.m_dayGos + 1] = trans[i].gameObject
                        end
                    end
                end
            end
        end,self.m_instanceModel)
        newRoom:OnEnter()
        --绑定房间点击事件
        local roomBox = self:GetGo(Environment, v.object_name .. "/roombox")
        local roomID = v.id
        self:SetButtonClickHandler(roomBox, function()
            self:OnRoomBeClicked(roomID)
        end)
        self:RefreshRoom(v.id)
    end
end

---virtual 初始化功能房间的相关数据，宿舍和食堂等
function CycleInstanceSceneBase:InitInteractionRoomData(roomID)
end

---virtual 房间被点击后
function CycleInstanceSceneBase:OnRoomBeClicked(clickRoomID)
end

--刷新互动的物体的数据状态
function CycleInstanceSceneBase:RefreshInteractionRoomData(roomID)
    local roomConfig = self.roomsConfig[roomID]
    local localData = {
        unlock = true,
        furnitures = {},
    }
    local roomData = {
        go = self:GetRoomGameObjectByID(roomID),
        config = roomConfig,
        employee = {},
        furnituresGo = {},
        drakFlag = {},
    }
    for k, v in pairs(self.Rooms[roomID].roomGO.furList) do
        local workPos1 = self:GetGoOrNul(v, "workPos" .. "_" .. 1)
        if workPos1 then
            roomData.furnituresGo[k] = workPos1.transform.parent.gameObject
        end
    end
    for k, v in pairs(roomData.furnituresGo) do
        local state = self.roomsData[roomID].furList[tostring(k)].state
        if not localData.furnitures[k] then
            localData.furnitures[k] = {}
        end
        localData.furnitures[k].level = state
    end
    local RefreshData = function(interactions)
        if interactions then
            interactions.m_localData = localData
            interactions.m_sceneProcessData = roomData
            interactions.m_furnitureChanged = 1
        end
    end
    --餐厅
    if roomConfig.room_category == 3 then
        RefreshData(InteractionsManager:GetEntity(ActorDefine.Flag.FLAG_INSTANCEWORKER_ON_EATING, self.Rooms[roomID].GORoot:GetInstanceID()))
    end
    --宿舍
    if roomConfig.room_category == 2 then
        RefreshData(InteractionsManager:GetEntity(ActorDefine.Flag.FLAG_INSTANCEWORKER_ON_SLEEPING, self.Rooms[roomID].GORoot:GetInstanceID()))
    end
end

---获取某个房间的根节点
function CycleInstanceSceneBase:GetRoomGameObjectByID(roomID)
    return self.Rooms[roomID].GORoot
end

---获取房间对象
function CycleInstanceSceneBase:GetRoomByID(roomID)
    return self.Rooms[roomID]
end

---检查是否需要新增员工
function CycleInstanceSceneBase:CreateWorkers(furnitureGo, roomGo, furIndex, isBuy, roomID,personList)
    local roomData = self.roomsData[roomID]
    local room = self.Rooms[roomID]
    local levelID = roomData.furList[tostring(furIndex)].id
    local furConfig = self.m_instanceModel:GetFurLevelConfigByLevelID(levelID)
    local workerCount = furConfig.worker
    local curFurnitureWorkers = room.workers[furIndex]
    local curWorkCount = 0
    if not curFurnitureWorkers then
        curFurnitureWorkers = {}
        room.workers[furIndex] = curFurnitureWorkers
    else
        curWorkCount = Tools:GetTableSize(curFurnitureWorkers)
    end
    if workerCount > curWorkCount then
        for workPosIndex = curWorkCount+1, workerCount do
            local newWorker = self:NewCreateWorker(furnitureGo, roomGo, workPosIndex, isBuy, roomID)
            curFurnitureWorkers[workPosIndex] = newWorker
            table.insert(personList,newWorker)
        end
        self:OnWorkerCountChange(room)
    end
end

---virtual 员工数量变化后调用
function CycleInstanceSceneBase:OnWorkerCountChange(room)

end

local ActorPath = "GamePlay.CycleInstance.BaseActor."

--- 创建基础Actor 只会原地播放work动画,子类复写
function CycleInstanceSceneBase:NewCreateWorker(furnitureGo, roomGo, index, isBuy, roomId)

    local spawnPosTr = self:GetTrans(roomGo, "spawnPos")  -- 出生点

    local workPosTr = self:GetTrans(furnitureGo, "workPos_"..index) --工位点

    local facePosTr = self:GetTrans(workPosTr.gameObject, "face") --工位点朝向

    local actionPosTr = self:GetTrans(roomGo, "actionPos/actionPos_" .. index) or workPosTr --工作点

    local faceTr = self:GetTrans(roomGo, "actionPos/actionPos_" .. index .. "/face") or facePosTr

    local pfbName = ConfigMgr.config_character[tonumber(self.roomsData[roomId].furList[tostring(1)].worker.prefab[index])].prefab

    local furData = self.roomsData[roomId].furList[tostring(1)]
    local data = {
        buildID = "instance", --所属建筑ID,这里把副本场景也看成一个building
        roomID = roomId, --所属房间ID
        furnitureID = furData.id, --所属家具ID
        furnitureIndex = 1 --所属家具位置索引
    }
    local prefabPath = "Assets/Res/Prefabs/character/Instance/" .. pfbName .. ".prefab"

    local spawnPos = spawnPosTr.position

    local worker = ActorManager:CreateActorSync("CycleInstanceBaseActor",data,ActorPath)  ---@type CycleInstanceWorkerClass
    GameResMgr:AInstantiateObjectAsyncManual(prefabPath, worker, function(go)
        UnityHelper.AddChildToParent(self.m_personRoot.transform, go.transform)
        worker:Init(worker.instanceID,go,{
            roomId = roomId,
            furIndex = index,
            workPosTr = workPosTr,
            workFaceTr =  facePosTr,
            actPosTr = actionPosTr,
            actFaceTr = faceTr,
            roomGO = roomGo,
            furGo = furnitureGo,
            spawnPos = spawnPos,
        },spawnPosTr.position,spawnPosTr.rotation,isBuy)
    end)

    return worker
end


---刷新房子的相关表现
function CycleInstanceSceneBase:RefreshRoom(roomID, index,isBuy)
    local roomData = self.roomsData[roomID]
    local isBuildComplete = false
    if roomData.state == 1 then
        --如果是修建状态,判断当前是否修建完成,如果完成则刷新显示并修改存档
        local currentTP = GameTimeManager:GetCurrentServerTime(true)
        if currentTP >= self.m_instanceModel:GetRoomUnlockTime(roomID) then
            self.m_instanceModel:SetRoomData(roomID, roomData.buildTimePoint, 2)
            self.Rooms[roomID]:HideBubble(CycleInstanceDefine.BubbleType.IsBuilding)
            isBuildComplete = true
        else
            --显示房屋悬浮图标
            self.Rooms[roomID]:ShowBubble(CycleInstanceDefine.BubbleType.IsBuilding)
        end
    elseif roomData.state == 2 then
        --self.Rooms[roomID]:ShowBubble(2)
    end
    self.Rooms[roomID]:ShowRoom()
    if isBuildComplete then
        self.Rooms[roomID]:OnBuildCompleted()
    end
    if index then
        self.Rooms[roomID]:ShowFurniture(index, isBuy)
    else
        self.Rooms[roomID]:ShowFurniture(nil, isBuy)
    end
end

---刷新副本房间
function CycleInstanceSceneBase:RefreshScene(roomID)
    for k, v in pairs(self.roomsData) do
        self:RefreshRoom(v.roomID)
    end
end

---显示所选的家具
function CycleInstanceSceneBase:ShowSelectFurniture(furGO, preBuy)
    -- 先还原上次操作的对象
    if self.m_selectFurniture then
        if self.m_lastSelectIsPrebuy then
            -- 将材质还原
            self:RevertMeshRendererMaterial()
            self.m_selectFurniture:SetActive(false)
        else
            self:StopFurnitureGlinting(self.m_selectFurniture)
        end
    end
    if not furGO then
        return
    end

    self.m_lastSelectIsPrebuy = preBuy
    self.m_selectFurniture = furGO
    furGO:SetActive(true)
    if preBuy then
        -- 替换Prebuy材质
        local blink = self:GetGoOrNul(furGO,"blink")
        local skin = self:GetGoOrNul(furGO,"skin")
        if blink then
            blink:SetActive(true)
        end
        if skin then
            skin:SetActive(false)
        end
        local meshRenderers = blink.gameObject:GetComponentsInChildren(typeof(MeshRenderer))
        local count = meshRenderers.Length
        for i=0,count-1 do
            local go = meshRenderers[i].gameObject
            if go.name ~= "shadow" then
                self:AddMeshRendererMaterial(go, preBuyMatPath)
            end
        end

    else
        self:StartFurnitureGlinting(furGO)
        return
    end

end

function CycleInstanceSceneBase:RevertMeshRendererMaterial()
    for meshRenderer,v in pairs(self.revertMaterialData or {}) do
        -- local materials = meshRenderer.materials
        -- materials[v.index] = v.oldMaterial
        -- meshRenderer.materials = materials
        for k,data in pairs(v) do
            UnityHelper.SetMeshRendererMaterial(meshRenderer, data.oldMaterial, data.index)
        end
        local SkodeGlinting = meshRenderer.gameObject:GetComponent("Skode_Glinting")
        if SkodeGlinting then
            SkodeGlinting:ResetMaterials()
        end
    end
    self.revertMaterialData = {}
end


function CycleInstanceSceneBase:StopFurnitureGlinting(furnitureGo)
    if self.m_glinting and self.m_glinting.meshRenderers then
        GameTimer:StopTimer(self.m_glinting.timer)
        for i=1,#self.m_glinting.materials do
            local mat = self.m_glinting.materials[i]
            --if mat:HasProperty("flash") then
            --    mat:SetFloat("flash", 0);
            --end
            if mat:HasProperty("DoFlash") then
                mat:SetFloat("DoFlash", 0);
            end
        end
        local blink = self:GetGo(furnitureGo,"blink")
        local skin = self:GetGo(furnitureGo,"skin")

        blink:SetActive(false)
        skin:SetActive(true)

        -- MaterialPropertyBlock 方案因在手机上有功能异常所以弃用
        --for i=0,self.m_glinting.meshRenderers.Length -1  do
        --    UnityHelper.SetBlockToMaterial(self.m_glinting.meshRenderers[i],false)
        --end
        self.m_glinting = nil
    end
end

function CycleInstanceSceneBase:StartFurnitureGlinting(furnitureGo)
    if not furnitureGo then
        return
    end
    --self:StopFurnitureGlinting()

    local blink = self:GetGoOrNul(furnitureGo,"blink")
    if not blink then
        return
    end
    local skin = self:GetGo(furnitureGo,"skin")
    blink:SetActive(true)
    skin:SetActive(false)
    local meshRenderers = blink:GetComponentsInChildren(typeof(MeshRenderer))
    local MaterialPropertyBlock = nil
    for i=0,meshRenderers.Length -1  do
        MaterialPropertyBlock = UnityHelper.SetBlockToMaterial(meshRenderers[i],true)
    end
    local materials = {}
    for i=0,meshRenderers.Length -1  do
        local meshRenderer = meshRenderers[i]
        for k=0,meshRenderer.materials.Length-1 do
            materials[#materials + 1] = meshRenderer.materials[k]
        end
    end


    local count = #materials

    self.m_glinting = {
        ["materials"] = materials,
        ["meshRenderers"] = meshRenderers,
        --["MaterialPropertyBlock"] = MaterialPropertyBlock,
        ["timer"] = nil,
        ["time"] = 0,
        ["deltaV"] = deltaV
    }

    for i=1,count do
        local mat = materials[i]
        if mat:HasProperty("DoFlash") then
            mat:SetFloat("DoFlash", 1);
        end
    end

end

function CycleInstanceSceneBase:AddMeshRendererMaterial(go, address, index)
    if not go then
        return
    end
    if not self.revertMaterialData then
        self.revertMaterialData = {}
    end

    local meshRenderer = go:GetComponent("MeshRenderer")
    if meshRenderer then
        local materials = meshRenderer.materials
        if not index then
            for i = 1, materials.Length do
                self:AddMeshRendererMaterial(go, address, i)
            end
            return
        end

        local index = materials.Length - index
        if index < 0 then
            return
        end
        local material = self:LoadMaterials(address)
        if not material then
            return
        end
        if not self.revertMaterialData[meshRenderer] then
            self.revertMaterialData[meshRenderer] = {}
        end
        table.insert(self.revertMaterialData[meshRenderer], { index = index, oldMaterial = materials[index] })
        UnityHelper.SetMeshRendererMaterial(meshRenderer, material, index)

        -- MaterialPropertyBlock 方案因在手机上有功能异常所以弃用
        -- materials[index] = material
        -- meshRenderer.materials = materials
    end
end

-- 1号房间播7-1，2号房间播7-3，后续都播7-2, 在 CycleInstanceModelBase:SetRoomData 切换BGM
function CycleInstanceSceneBase:PlayBGM()
    local bgm = nil
    if self.m_instanceModel.instance_id == 7 then
        local room_data2 = CycleInstanceDataManager:GetCurrentModel():GetCurRoomData(1045)
        if not room_data2 or room_data2.state ~= 2 then
            bgm = "bgm_instance_7_1"
        else
            local room_data3 = CycleInstanceDataManager:GetCurrentModel():GetCurRoomData(1046)
            if not room_data3 or room_data3.state ~= 2 then
                bgm = "bgm_instance_7_3"
            end
        end
    end

    if not bgm then -- bgm_instance_7_2
        local instanceBind = CycleInstanceDataManager:GetInstanceBind(self.m_instanceModel.instance_id)
        bgm = instanceBind.bgm
    end

    local bgmPlay = SoundEngine[bgm]
    SoundEngine:PlayBackgroundMusic(bgmPlay, true)
end

function CycleInstanceSceneBase:StopBGM()
    SoundEngine:StopBackgroundMusic(true)
end

---初始化IAA演员
function CycleInstanceSceneBase:InitEventActor()
    local IAA = GameObject.Find("IAA")
    local go = self:GetGo(IAA,"AdNPC").gameObject
    local start = GameObject.Find("IAA/StartPos")
    local dstPos = GameObject.Find("IAA/DstPos")
    local facePos = GameObject.Find("IAA/DstPos/face")
    self.eventInstance = EventInstance:CreateActor() ---@type EventInstanceNew
    self.eventInstance.m_tempGo = go
    --self.eventInstance.m_rootGo = go.transform.parent.gameObject
    --self.eventInstance:CreateGo()
    -- local trempGo = GameObject.Instantiate(go)
    self.eventInstance:Init(IAA,go,start.transform.position, dstPos.transform.position,facePos.transform.position, 101)

end


---刷新场景光照
function CycleInstanceSceneBase:RefreshLight()
    local curInstanceTime = self.m_instanceModel:GetCurInstanceTime()
    if curInstanceTime.Hour ~= self.m_instanceModel.lastTime.Hour then
        if curInstanceTime.Hour == tonumber(self.m_instanceModel.config_global.cycle_instance_timenode[1]) then
            EventManager:DispatchEvent("DAY_COME")
        elseif tonumber(curInstanceTime.Hour) == tonumber(self.m_instanceModel.config_global.cycle_instance_timenode[2]) then
            EventManager:DispatchEvent("NIGHT_COME")
        end
    end
end

--- 获取家具GameObject
function CycleInstanceSceneBase:GetSceneRoomFurnitureGo(roomID, furnitureIndex, index)
    if not self.Rooms[roomID] then
        return nil
    end
    if index then
        local subFurGO = self.Rooms[roomID]:GetSubFurnitureGoByIndex(index)
        if not subFurGO then
            error("找不到家具roomID="..roomID..",subIndex="..index)
        end
        return subFurGO
    end

    return self.Rooms[roomID]:GetFurnitureGoByIndex(furnitureIndex)
end


---切换相机lookat目标
function CycleInstanceSceneBase:LookAtSceneGO(roomID, furIndex, cameraFocus, isBack,callback)
    if not furIndex then
        local roomGO = self:GetRoomGameObjectByID(roomID)
        self:LocatePosition(roomGO.transform.position, true,callback)
    elseif not cameraFocus then
        local furGO = self:GetSceneRoomFurnitureGo(roomID, furIndex)
        self:LocatePosition(furGO.transform.position, true,callback)
    else
        local furGO = self:GetSceneRoomFurnitureGo(roomID, furIndex)
        local size = cameraFocus.m_cameraSize
        local speed = cameraFocus.m_cameraMoveSpeed
        local target2DPosition = cameraFocus.transform.position
        local cb = callback
        if isBack then
            local data = self:GetSetCameraLocateRecordData() or {}
            data.isBack = true
            size = data.offset or size
            target2DPosition = data.offset2dPosition
            furGO = data.go3d
            cb = callback
        elseif not self:GetSetCameraLocateRecordData() then
            cb = function()
                -- local roomCfg = ConfigMgr.config_rooms[self.m_curRoomId]
                -- SoundEngine:PlaySFX(SoundEngine.ROOM_SFX[roomCfg.category[2]])
                if callback then
                    callback()
                end
            end
        end
        if not furGO or furGO:IsNull() then
            return
        end
        self:Locate3DPositionByScreenPosition(furGO, target2DPosition, size, speed, cb)
    end
end

---相机看向场景中的某个物体
function CycleInstanceSceneBase:LookAtGameObject(gameObject, cameraFocus, isBack,callback)
    local size = cameraFocus.m_cameraSize
    local speed = cameraFocus.m_cameraMoveSpeed
    local target2DPosition = cameraFocus.transform.position
    local cb = callback
    if isBack then
        local data = self:GetSetCameraLocateRecordData() or {}
        data.isBack = true
        size = data.offset or size
        target2DPosition = data.offset2dPosition
        gameObject = data.go3d
    end
    if not gameObject or gameObject:IsNull() then
        return
    end
    self:Locate3DPositionByScreenPosition(gameObject, target2DPosition, size, speed, cb)
end

--- 事件角色切换到返回状态
function CycleInstanceSceneBase:EventInstanceBack()
    if self.eventInstance then
        self.eventInstance.m_stateMachine:ChangeState(ActorDefine.State.EventInstanceLeaving)
    end
end

---检查该播放哪个入场TimeLine.
function CycleInstanceSceneBase:CheckToPlayOpeningTimeLine()
    local openingTimeLinePath = self.m_instanceModel.config_instance_bind.opening
    --播放初到场景的开场TimeLine
    if not self.m_instanceModel:GetIsPlayedOpeningTimeLine() and openingTimeLinePath then
        self:PlayTimeLine(openingTimeLinePath,function()
            --标记为已播放OpeningTimeLine
            self.m_instanceModel:SetIsPlayedOpeningTimeLine()
            self:OnOpeningTimeLineOver()
        end)
    else
        --除了第一次以外，每次进入场景都要播放的TimeLine
        self:PlayEnterTimeLine(function()
            self:OnOpeningTimeLineOver()
        end)
    end
end

--- 播放TimeLine
function CycleInstanceSceneBase:PlayTimeLine(timelineName,cb_OnEnd)
    --隐藏界面
    local mainUI = CycleInstanceDataManager:GetCycleInstanceMainViewUI()
    if mainUI.GuideTimeUIState then
        mainUI:GuideTimeUIState()
    else
        printf("此副本MainUI还没有隐藏的方法")
    end
    EventManager:RegEvent("START_TALK", function(go, args)
        TalkUI:OpenTalk("cutscene" .. tonumber(args[1]), {bossName = LocalDataManager:GetBossName()}, function()
            GameUIManager:SetEnableTouch(false)
            UnityHelper.PlayTimeLine(self.m_GuideTimeLine)
            if self.m_GuideTimeLine then
                self.m_GuideTimeLine:Play()
            end
            GameSDKs:TrackForeign("opening_timeline",{start_state = "success", end_state = "failed"})
        end, function()
            GameUIManager:SetEnableTouch(true)
            GameSDKs:TrackForeign("opening_timeline",{start_state = "failed", end_state = "success"})
        end, self.m_GuideTimeGo)
    end)

    EventManager:RegEvent("EVENT_GUIDE_TIMELINE_END", function(go)
        GameUIManager:SetEnableTouch(true)
        GameObject.Destroy(self.m_GuideTimeGo)
        self.m_GuideTimeGo = nil
        self.m_GuideTimeLine = nil
        UnityHelper.RemoveCameraFromCameraStack(GameUIManager:GetSceneCamera(), self.m_storyCamera)
        UnityHelper.RemoveCameraFromCameraStack(GameUIManager:GetSceneCamera(), self.m_storyUICamera)
        GuideManager.timeLineDone = true
        self.m_storyCamera = nil
        self.m_storyUICamera = nil
        if mainUI.GuideTimeUIState then
            mainUI:GuideTimeUIState(true)

            -- 先做个容错，其它副本不应该加载5号副本的礼包 
            if self.instance_id == 5 then
                GameTableDefine.CycleCastlePopUI:PackTrigger(4)
            end
            
        else
            printf("此副本MainUI还没有隐藏的方法")
        end

        --从新播放场景BGM
        SoundEngine:UnCatchAndStopSceneBGM()
        LocalDataManager:WriteToFileInmmediately()
        EventManager:UnregEvent("EVENT_GUIDE_TIMELINE_END")
        if cb_OnEnd then
            cb_OnEnd()
        end
    end)

    self.m_GuideTimeLine = -1
    GameResMgr:AInstantiateObjectAsyncManual("Assets/Res/Prefabs/Timeline/" .. timelineName .. ".prefab", self, function(childGo)
        local skinGo = self:GetGoOrNul(childGo, "People/Boss/"..LocalDataManager:GetBossSkin())
        if skinGo then
            skinGo:SetActive(true)
        end
        --2022-12-9 timeline播放和装扮系统整合的功能
        GameTableDefine.DressUpDataManager:ChangeTimelineActorDressUp(childGo)
        self.m_GuideTimeGo = childGo
        self.m_GuideTimeLine = childGo:GetComponent("PlayableDirector")
        self.m_storyCamera = UnityHelper.GetTheChildComponent(childGo, "CameraCG", "Camera")
        self.m_storyUICamera = UnityHelper.GetTheChildComponent(childGo, "UI_Camera_Story", "Camera")
        if self.m_storyUICamera then
            UnityHelper.SetCameraRenderType(self.m_storyUICamera, 1)
            UnityHelper.AddCameraToCameraStack(GameUIManager:GetSceneCamera(), self.m_storyUICamera, 0)
        end
        if self.m_storyCamera then
            UnityHelper.SetCameraRenderType(self.m_storyCamera, 1)
            UnityHelper.AddCameraToCameraStack(GameUIManager:GetSceneCamera(), self.m_storyCamera, 0)
        end
        GameUIManager:SetEnableTouch(false)
    end)
end

--- 播放TimeLine
function CycleInstanceSceneBase:PlayEnterTimeLine(cb_OnEnd)

    local enterTimeLineGO = UnityHelper.FindRootGameObject("EnterTimeline")
    if enterTimeLineGO and not enterTimeLineGO:IsNull() then
        enterTimeLineGO:SetActive(true)
    else
        if cb_OnEnd then
            cb_OnEnd()
        end
        return
    end

    --隐藏界面
    local mainUI = CycleInstanceDataManager:GetCycleInstanceMainViewUI()
    if mainUI.GuideTimeUIState then
        mainUI:GuideTimeUIState()
    else
        printf("此副本MainUI还没有隐藏的方法")
    end

    EventManager:RegEvent("EVENT_GUIDE_TIMELINE_END", function(go)
        GameUIManager:SetEnableTouch(true)
        --不会再用到，应该能删掉释放内存
        GameObject.Destroy(self.m_GuideTimeGo)
        self.m_GuideTimeGo = nil
        self.m_GuideTimeLine = nil
        UnityHelper.RemoveCameraFromCameraStack(GameUIManager:GetSceneCamera(), self.m_storyCamera)
        UnityHelper.RemoveCameraFromCameraStack(GameUIManager:GetSceneCamera(), self.m_storyUICamera)
        self.m_storyCamera = nil
        self.m_storyUICamera = nil
        GuideManager.timeLineDone = true
        if mainUI.GuideTimeUIState then
            mainUI:GuideTimeUIState(true)
        else
            printf("此副本MainUI还没有隐藏的方法")
        end

        --从新播放场景BGM
        SoundEngine:UnCatchAndStopSceneBGM()
        LocalDataManager:WriteToFileInmmediately()
        EventManager:UnregEvent("EVENT_GUIDE_TIMELINE_END")
        if cb_OnEnd then
            cb_OnEnd()
        end
    end)

    self.m_GuideTimeLine = -1

    self.m_GuideTimeGo = enterTimeLineGO
    self.m_GuideTimeLine = enterTimeLineGO:GetComponent("PlayableDirector")
    self.m_storyCamera = UnityHelper.GetTheChildComponent(enterTimeLineGO, "CameraCG", "Camera")
    self.m_storyUICamera = UnityHelper.GetTheChildComponent(enterTimeLineGO, "UI_Camera_Story", "Camera")
    if self.m_storyUICamera then
        UnityHelper.SetCameraRenderType(self.m_storyUICamera, 1)
        UnityHelper.AddCameraToCameraStack(GameUIManager:GetSceneCamera(), self.m_storyUICamera, 0)
    end
    if self.m_storyCamera then
        UnityHelper.SetCameraRenderType(self.m_storyCamera, 1)
        UnityHelper.AddCameraToCameraStack(GameUIManager:GetSceneCamera(), self.m_storyCamera, 0)
    end
    GameUIManager:SetEnableTouch(false)
end

---virtual 播放完开场TimeLine后触发
function CycleInstanceSceneBase:OnOpeningTimeLineOver()

end

---是否正在播放TimeLine
function CycleInstanceSceneBase:IsPlayingTimeLine()
    return self.m_GuideTimeLine and true or false
end

return CycleInstanceSceneBase