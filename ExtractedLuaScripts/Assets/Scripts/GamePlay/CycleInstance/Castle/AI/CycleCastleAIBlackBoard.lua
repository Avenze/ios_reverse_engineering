---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Microsoft-GXY.
--- DateTime: 2024/8/15 18:16
---
---@class CycleCastleAIBlackBoard
local CycleCastleAIBlackBoard = GameTableDefine.CycleCastleAIBlackBoard
local ActorDefine = require("CodeRefactoring.Actor.ActorDefine")
local BaseScene = require("Framework.Scene.BaseScene")
local UnityHelper = CS.Common.Utils.UnityHelper

local tableNameDic = {
    [1] = "table_1",
    [2] = "table_2",
    [3] = "table_3",
    [4] = "table_4",
    [5] = "table_5",
    [6] = "table_6",
    [7] = "table_7",
    [8] = "table_8",
    
}
local tableList = nil  -- 桌子队列

function CycleCastleAIBlackBoard:Init(navData, roomGO)
    self.comeStartPos = BaseScene:GetGo(navData, "pos_1")
    self.comeEndPos = BaseScene:GetGo(navData, "pos_2")
    self.leaveStartPos = BaseScene:GetGo(navData, "pos_3")
    self.leaveEndPos = BaseScene:GetGo(navData, "pos_4")
    
    local randomIn = BaseScene:GetGo(navData, "in")
    local randomOut = BaseScene:GetGo(navData, "out")
    self.randomInChilds = UnityHelper.GetAllChilds(randomIn, true)
    self.randomOutChilds = UnityHelper.GetAllChilds(randomOut, true)
    
    self.diningRoom = {
        ["table_1"] = {},
        ["table_2"] = {},
        ["table_3"] = {},
        ["table_4"] = {},
        ["table_5"] = {},
        ["table_6"] = {},
        ["table_7"] = {},
        ["table_8"] = {},
    }
    for k,v in pairs(self.diningRoom) do
        self.diningRoom[k] = {} 
        local table = BaseScene:GetGo(roomGO, k)
        for i = 1, 6 do            
            self.diningRoom[k][i] = BaseScene:GetGo(table, "workPos_" .. i)
        end        
    end
    self:InitTableList()
    --printf(dump(self.diningRoom, 2, true))
    
end 

function CycleCastleAIBlackBoard:InitTableList()
    if not tableList then
        tableList = {}
    end
    for k, v in pairs(self.diningRoom) do
        tableList[k] = {}
        for seatIndex, seatGo in pairs(self.diningRoom[k]) do
            table.insert(tableList[k], { index = seatIndex, client = nil })
        end
        tableList[k] = Tools:ShuffleArray(tableList[k])
    end
end

--处理占座逻辑, 返回座位GO
function CycleCastleAIBlackBoard:OccupySeat(team, client)
    local tableIndex = team.data.tableIndex
    local tableName = tableNameDic[tableIndex]
    local seatIndex = nil
    for k, v in ipairs(tableList[tableName]) do
        if not v.client then
            seatIndex = v.index
            v.client = client
            break
        end
    end
    local seatGo = self.diningRoom[tableName][seatIndex]
    return seatGo
end

--离开座位逻辑, 离开座位时将座位顺序打乱作为下一次的排座顺序
function CycleCastleAIBlackBoard:LeaveSeat(tableIndex)
    local tableName = tableNameDic[tableIndex]
    if tableList[tableName] then
        for k, v in pairs(tableList[tableName]) do
            if v.client then
                if not v.client.data.leader then
                    v.client.m_stateMachine:ChangeState(ActorDefine.CycleInstanceState.CycleCastleClientGetUp)
                else
                    v.client.m_stateMachine:ChangeState(ActorDefine.CycleInstanceState.CycleCastleClientGetUp)
                end
            end
        end
    end
  
    tableList[tableName] = {}
    for k, v in pairs(self.diningRoom[tableName]) do
        table.insert(tableList[tableName], { index = k, client = nil })
    end
    tableList[tableName] = Tools:ShuffleArray(tableList[tableName])
end




return CycleCastleAIBlackBoard
