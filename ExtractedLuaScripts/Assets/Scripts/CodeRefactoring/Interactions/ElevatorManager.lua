---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chenlongfa.
--- DateTime: 2024/6/7 11:51
---

local Class = require("Framework.Lua.Class")
---@class ElevatorManager
local ElevatorManager = GameTableDefine.ElevatorManager
--local Elevator = require("CodeRefactoring.Interactions.Elevator")

function ElevatorManager:ctor()
    if self.m_initialized then
        return
    end
    self.m_initialized = true
    self.m_elevators = {} ---@type Elevator[]
    self.m_groups = {} ---@type table<number,Elevator[]>
end

---@param entity Elevator
function ElevatorManager:AddEntity(entity)
    table.insert(self.m_elevators,entity)

    local posY = entity.m_go.transform.position.y

    local group = self:FindGroup(posY)

    if not group then
        group = {}
        self.m_groups[posY] = group
    end
    table.insert(group,entity)
end

---@param entity Elevator
function ElevatorManager:RemoveEntity(entity)
    table.RemoveValue(self.m_elevators,entity)
    for posY,group in pairs(self.m_groups) do
        for i,v in ipairs(group) do
            if v == entity then
                table.remove(group,i)
                return
            end
        end
    end
end

function ElevatorManager:FindGroup(posY)
    for k,v in pairs(self.m_groups) do
        if math.abs(posY-k) < 1 then
            return v
        end
    end
    return nil
end

--创建电梯组，按楼层划分
--function ElevatorManager:BuildElevatorGroups()
--    self.m_groups = {}
--    for k,v in pairs(self.m_elevators) do
--        local posY = v.m_colliderComponent.transform.position.y
--        local group = self:FindGroup(posY)
--        if not group then
--            group = {}
--            self.m_groups[posY] = group
--        end
--        table.insert(group,v)
--    end
--end

---获取一个sourcePosY附近的能到达目标楼层的电梯,并随机返回一个
---@return Elevator
function ElevatorManager:GetElevatorsByFloor(sourcePosY, targetPosY)
    --1.计算距目标最近电梯Y轴位置,约等于找本层楼的电梯
    local minDis = 99999
    local nearGroup = nil ---@type Elevator[]
    for posY,group in pairs(self.m_groups) do
        local dis = math.abs(posY- sourcePosY)
        if dis < minDis then
            nearGroup = group
            minDis = dis
        end
    end
    if not nearGroup then
        return nil
    end
    --2.找出所有能到达目标Y的电梯
    local canGoToTargetElevators = {}
    for k,elevator in pairs(nearGroup) do
        for i,floorGO in ipairs(elevator.m_targetTransform) do
            if math.abs( floorGO.transform.position.y - targetPosY) < 6 then
                table.insert(canGoToTargetElevators,elevator)
                break
            end
        end
    end
    --3.随机一个
    local elevatorCount = #canGoToTargetElevators
    if elevatorCount > 0 then
        local randomIndex = math.random(1, elevatorCount)
        local resultElevator = canGoToTargetElevators[randomIndex]

        return resultElevator
    else
        return nil
    end
end

---返回目标点是否和这个Person在同一个楼层
function ElevatorManager:CheckDestinationInSameLevel(pos1,pos2)
    if not pos2 then
        return false
    end
    return math.abs(pos1.y - pos2.y) < 5
end

---电梯传送的统一接口
---@param person PersonBase
---@param elevatorCR ColliderResponse
---@param destination UnityEngine.Vector3
function ElevatorManager:TransformActorByElevator(person,elevatorCR,destination)

    local transform = person.m_go.transform ---@type UnityEngine.Transform
    local curPos = transform.position
    --同一层不触发传送
    if self:CheckDestinationInSameLevel(curPos,destination) then
        return false
    end

    local goalPosY = destination.y
    local goalFloorY = 99
    local minDis = 99

    --1.计算距目标最近电梯Y轴位置
    local floors = elevatorCR.m_floors
    for i = 0, floors.Length - 1 do
        local v = floors[i]
        local dis = math.abs(goalPosY - v.transform.position.y)
        if dis < minDis then
            minDis = dis
            goalFloorY = v.transform.position.y
        end
    end
    --2.计算最近电梯Y的1m内所有电梯
    local allGoals = {}
    for i = 0, floors.Length - 1 do
        local v = floors[i]
        local dis = math.abs(goalFloorY - v.transform.position.y)
        if dis < 1 then
            table.insert(allGoals,#allGoals+1,i)
        end
    end
    --3.随机一个电梯
    local randomIndex = math.random(1, #allGoals)
    local goalFloor = allGoals[randomIndex]

    --4.位移
    local pos = floors[goalFloor].transform.position
    transform.position = pos

    --记录传送后到达的电梯GameObject
    local nextPos = floors[goalFloor]:GetComponent("ColliderResponse")
    if nextPos then
        person.m_transfer = nextPos
    end
end

ElevatorManager:ctor()

return ElevatorManager