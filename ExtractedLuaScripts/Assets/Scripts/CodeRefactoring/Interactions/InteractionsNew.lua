---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chenlongfa.
--- DateTime: 2023/9/26 10:18
---

local Class = require("Framework.Lua.Class")
---@class InteractionsNew
local InteractionsNew = Class("InteractionsNew")

local FloorMode = GameTableDefine.FloorMode
local CfgMgr = GameTableDefine.ConfigMgr
local GameClockManager = GameTableDefine.GameClockManager
local GreteBuildingMana = GameTableDefine.GreateBuildingMana
local ActorDefine = require("CodeRefactoring.Actor.ActorDefine")

local UnityHelper = CS.Common.Utils.UnityHelper

local TimeManager = GameTimeManager
--local LuaBehavior = CS.Framework.Lua.LuaBehavior
local InteractionsManager = require("CodeRefactoring.Interactions.InteractionsManager")
local Timer = GameTimer
local Tools = Tools

local personUpdateInteractionTag = nil

function InteractionsNew:ctor()
    self.m_go = nil ---@type UnityEngine.GameObject
    self.m_luaBehavior = nil ---@type Framework.Lua.LuaBehavior
    self.m_colliderComponent = nil ---@type ColliderResponse

    self.m_formula = nil
    self.m_threshold = 0
    self.m_enableQueue = false
    self.m_tag = nil
    self.m_interactionType = nil
    self.m_meetingTime = nil
    self.m_personMood = nil
    self.m_objID = nil

    --RoomData
    self.m_localData = nil
    self.m_roomUnlock = nil
    self.m_furnitureChanged = nil
    self.m_currRoomIndex = nil
    self.m_config = nil
    self.m_sceneProcessData = nil
    self.m_entityRoomID = nil
    self.m_floor = 1
    self.m_roomIndex = nil ---会议室才会使用，占用此会议室的办公室ID

    self.m_furniturePosition = {}
    self.m_furnitureAnim = {}
    self.m_personQueue = {}
    self.m_timerID = nil ---Update的Timer

    self.m_needUpdateQueue = false
    self.m_queueStartPoint = nil ---@type UnityEngine.Transform---队伍起点，Employee会走向这个点然后进入排队状态
    self.m_queuePath = nil ---@type UnityEngine.Vector3[] -排队的路径点
end

function InteractionsNew:Init(component, tag, type)
    self.m_go = component.m_roomObject ---@type UnityEngine.GameObject
    self.m_luaBehavior = UnityHelper.GetOrAddLuaBehavior(self.m_go) ---@type Framework.Lua.LuaBehavior
    self.m_luaBehavior:SetOnDestroyEvent(handler(self,self.OnDestroy))
    self.m_colliderComponent = component

    self.m_queueStartPoint = self.m_colliderComponent.m_queueStartPoint.transform
    self.m_formula = loadstring("return " .. self.m_colliderComponent.m_formula)()
    self.m_threshold = self.m_colliderComponent.m_threshold
    self.m_enableQueue = self.m_colliderComponent.m_enableQueue
    self.m_tag = tag
    self.m_interactionType = type
    self.m_meetingTime = self.m_colliderComponent.m_meetingTime
    self.m_personMood = {}
    for i = 0, self.m_colliderComponent.m_persionMood.Length - 1 do
        local v = self.m_colliderComponent.m_persionMood[i]
        table.insert(self.m_personMood, {x=v.x, y=v.y})
    end
    self.m_timerID = Timer:CreateNewTimer(1,function()
        self:Update()
    end,true)
end

function InteractionsNew:Update()
    if not self.m_personQueue or #self.m_personQueue == 0 then
        return
    end

    local idlePosition = self:GetFurnitureIdlePosition()
    if idlePosition then
        self:PersonGetIn(idlePosition)
    end

    --解雇排队中的人后需要刷新
    if self.m_needUpdateQueue then
        self:UpdateQueue()
        self.m_needUpdateQueue = false
    end
end

function InteractionsNew:OnDestroy()
    self.m_luaBehavior:ClearOnDestroyEvent()
    self.m_luaBehavior = nil
    self.m_flags = 0
    InteractionsManager:RemoveEntity(self)
    self.m_tag = nil
    self.m_queuePath = nil
    self.m_furniturePosition = nil
    self.m_furnitureAnim = nil
    self.m_personQueue = nil
    --RoomData
    self.m_localData = nil
    self.m_roomUnlock = nil
    self.m_furnitureChanged = nil
    self.m_currRoomIndex = nil
    self.m_config = nil
    self.m_sceneProcessData = nil
    self.m_roomIndex = nil
    self.m_colliderComponent = nil
    self.m_queueStartPoint = nil
    self.m_needUpdateQueue = false
    self.m_entityRoomID = nil
    if self.m_timerID then
        Timer:StopTimer(self.m_timerID)
        self.m_timerID = nil
    end
end

function InteractionsNew:SetData(config, localData, sceneProcessData)
    Timer:CreateNewTimer(2, function()
        if not self.m_localData or (not self.m_roomUnlock and localData.unlock) then
            self.m_furnitureChanged = localData.unlock and 1 or nil
        end

        self.m_roomUnlock = localData.unlock
        self.m_currRoomIndex = config.room_index
        self.m_config = config
        self.m_localData = localData
        self.m_sceneProcessData = sceneProcessData
        self.m_sceneProcessData.interactionsActor = self
        local scene = FloorMode:GetScene()
        if scene then
            self.m_entityRoomID = FloorMode:GetRoomIdByRoomIndex(self.m_currRoomIndex)
            self.m_floor = scene:GetRoomFloor(self.m_entityRoomID)
        else
            self.m_floor = 1
        end

        if self.m_furnitureChanged then
            self:SetPersonUpdateInteractionTag()
        end
    end)
end

---@param person CompanyEmployeeNew
function InteractionsNew:UpdatePersonInteraction(person,dt)
    self:Behavior(person,dt)
    self:CheckPersonMood(person)
end

---@param person CompanyEmployeeNew
function InteractionsNew:Behavior(person,dt)
    local haveAnyPosition = self:HaveAnyPosition()

    local meetRoomTrigger = person:GetInteractionEntity(ActorDefine.Flag.FLAG_EMPLOYEE_ON_MEETING)
    local gameH, gameM, gameD = GameClockManager:GetCurrGameTime()
    local curTime = gameH + (gameM / 60)
    if self.m_interactionType == ActorDefine.ColliderResponse.TYPE_GOTO_MEETING
            and person:HasFlag(ActorDefine.Flag.FLAG_EMPLOYEE_ON_WORKING)
            and not person:HasFlag(ActorDefine.Flag.FLAG_EMPLOYEE_ON_ACTION )
            and (person.m_stateMachine:IsState("EmployeeWorkState") or person.m_stateMachine:IsState("EmployeeGoToWorkState"))
            and person:CheckDailyMeetingValid()
    then
        if (self.m_roomIndex == nil or self.m_roomIndex == person.m_roomData.config.room_index)
                and self.m_meetingTime > 0
                and curTime >= self.m_meetingTime
                and haveAnyPosition
        then
            person:AddFlag(self.m_tag)
            self.m_roomIndex = person.m_roomData.config.room_index
        end
    elseif meetRoomTrigger and  meetRoomTrigger.m_roomIndex == person.m_roomData.config.room_index
            and person:HasFlag(ActorDefine.Flag.FLAG_EMPLOYEE_ON_WORKING)
            and not person:HasFlag(ActorDefine.Flag.FLAG_EMPLOYEE_ON_ACTION )
            and (person.m_stateMachine:IsState("EmployeeWorkState") or person.m_stateMachine:IsState("EmployeeGoToWorkState"))
            and person:CheckDailyMeetingValid()
    then
        person:AddFlag(ActorDefine.Flag.FLAG_EMPLOYEE_ON_MEETING)
    end

    if not person.m_triggerCounter[self.m_tag] then
        return
    end
    if self.m_interactionType == ActorDefine.ColliderResponse.TYPE_GOTO_TOILET
            or self.m_interactionType == ActorDefine.ColliderResponse.TYPE_GOTO_REST
            or self.m_interactionType == ActorDefine.ColliderResponse.TYPE_GOTO_ENTERTAINMENT
            or self.m_interactionType == ActorDefine.ColliderResponse.TYPE_GOTO_GYM
    then
        person.m_triggerCounter[self.m_tag] = person.m_triggerCounter[self.m_tag] + 0.5 * dt
        local probability = self.m_formula(person.m_triggerCounter[self.m_tag])
        local p = math.random(1, 100)

        local notHaveMeetingPosition = true
        if meetRoomTrigger then
            notHaveMeetingPosition = not (next(meetRoomTrigger:GetPosition()) and true or false)
        end

        if person.m_triggerCounter[self.m_tag] >= self.m_threshold
                and p < probability
                and not person:HasFlag(ActorDefine.Flag.FLAG_EMPLOYEE_ON_ACTION | ActorDefine.Flag.FLAG_EMPLOYEE_ON_TURN_BACK )
                and person:HasFlag(ActorDefine.Flag.FLAG_EMPLOYEE_ON_WORKING)
                and (person.m_stateMachine:IsState("EmployeeWorkState") or person.m_stateMachine:IsState("EmployeeGoToWorkState"))
                and (not meetRoomTrigger.m_meetingTime or notHaveMeetingPosition or curTime < meetRoomTrigger.m_meetingTime or not person:CheckDailyMeetingValid())
                and haveAnyPosition
        then
            person:AddFlag(self.m_tag)
        end
    end
end

---心情值的改变
---@param person CompanyEmployeeNew
function InteractionsNew:CheckPersonMood(person)
    --没有这项行为的需求
    if #self.m_personMood <= 0 or (person.m_triggerCounter[self.m_tag] or 0) < self.m_personMood[1].x then
        local moodStr = InteractionsNew:GetStringFromCache("interaction_type_",self.m_interactionType)
        person:SetTargetMood(moodStr)
        return
    end

    local target = nil
    for i,v in ipairs(self.m_personMood) do
        if person.m_triggerCounter[self.m_tag] >= v.x then
            target = v
        end
    end

    ---需要扣心情了
    if target then
        local targetMood = GreteBuildingMana:GetMoodImprove() --扣到下限
        local transferValue = math.ceil(target.y)  --/ 1000 -- / v.z * 1000
        local moodStr = InteractionsNew:GetStringFromCache("interaction_type_",self.m_interactionType)
        person:SetTargetMood(moodStr, targetMood, transferValue)
    end
end

function InteractionsNew:HaveAnyPosition()
    if self.m_furnitureChanged then
        self:GetPosition()
    end
    return next(self.m_furniturePosition) and true or false
end

function InteractionsNew:GetPosition()
    if self.m_furnitureChanged then
        self.m_colliderComponent:GetFurnitureGoData(self.m_furniturePosition, self.m_furnitureAnim)
        self.m_furnitureChanged = nil
        for fgo1,pos in pairs(self.m_furniturePosition) do
            for k, fgo2 in pairs(self.m_sceneProcessData.furnituresGo or {}) do
                if fgo1 ~= "randomPos" and pos.furnGo == fgo2 then
                    local furnitureData = self.m_localData.furnitures[k]
                    pos.localData = furnitureData.level > 0 and furnitureData or nil
                    break
                end
            end
            if self.m_tag == ActorDefine.Flag.FLAG_INSTANCEWORKER_ON_SLEEPING then -- 副本的卧室
                if pos.posGo:IsNull() or not pos.posGo or pos.posGo.activeInHierarchy == false then
                    self.m_furniturePosition[fgo1] = nil
                end
            end
            if not pos.localData then
                self.m_furniturePosition[fgo1] = nil
            end
        end
    end
    return self.m_furniturePosition
end

---获取会议桌的附件，给会议椅用
function InteractionsNew:GetMeetingTableAccessoryInfo()
    local furnitures = self.m_localData.furnitures
    local accessoryInfo = nil
    if furnitures then
        for k,v in pairs(furnitures) do
            if v.id == 10006 then
                accessoryInfo = v.accessory_info
                break
            end
        end
    end
    return accessoryInfo
end

---获取排队起点，走到这个点开始排队
function InteractionsNew:GetQueueStartPos()
    return self.m_queueStartPoint.position
end

---标识出现新增互动座位
function InteractionsNew:SetPersonUpdateInteractionTag()
    personUpdateInteractionTag = TimeManager:GetSocketTime()
end

function InteractionsNew:GetPersonUpdateInteractionTag()
    return personUpdateInteractionTag
end

---@param person CompanyEmployeeNew
function InteractionsNew:ResetTriggerCounter(person)
    if person.m_triggerCounter then
        person.m_triggerCounter[self.m_tag] = math.random(self.m_colliderComponent.m_behaviourInit.x, self.m_colliderComponent.m_behaviourInit.y)
    end
end

function InteractionsNew:GetFurnitureIdlePosition()
    local furniturePosition = self:GetPosition()
    local enableQueue = self.m_enableQueue
    for k, v in pairs(furniturePosition) do
        if v.person == nil then
            return v
        end
    end

    if not enableQueue and Tools:GetTableSize(furniturePosition) > 1 and furniturePosition["randomPos"] then
        local randomPos = Tools:CopyTable(furniturePosition["randomPos"])
        local pos = self.m_go.transform.position
        pos.x = pos.x + math.random(-6,6)
        pos.z = pos.z + math.random(-6,6)
        randomPos.pos = pos
        return randomPos
    end
    return nil
end


function InteractionsNew:PersonGetIn(idlePosition, per)
    if FloorMode:IsRoomBroken(self.m_currRoomIndex) then
        return false
    end

    local person = self:RemoveTopQueuePath(per)
    if person then
        idlePosition.person = person
        person.m_idlePosition = idlePosition
        --person:Event(ActorDefine.Event.EVENT_GET_IN_IDLE_POSITION, {
        --    pos = idlePosition.pos,
        --    dir = idlePosition.dir,
        --})
        person.m_stateMachine:ChangeState(ActorDefine.State.EmployeeToiletState,idlePosition.pos,idlePosition.dir)
    end
    if #self.m_personQueue > 0 then
        self:UpdateQueue()
    end
    return true
end

function InteractionsNew:PersonGetOut(person, personCount)
    if person.m_idlePosition then
        person.m_idlePosition.person = nil
        person.m_idlePosition = nil
    end
    if self.m_localData then
        self.m_localData.using_count = (self.m_localData.using_count or 0) + 1
    end
    ---Person离开队伍，出现空位
    local idlePosition = self:GetFurnitureIdlePosition()
    if idlePosition then
        self:PersonGetIn(idlePosition)
    end
end

---取出排在队伍最前面的Person
function InteractionsNew:RemoveTopQueuePath(per)
    local p = per or table.remove(self.m_personQueue, 1)
    if p then
        if p.m_queueBack then
            p.m_queueBack.m_queueFront = nil
        end
        p.m_queueBack = nil
    end
    return p
end

---从队列中移除Person
---@param per CompanyEmployeeNew
function InteractionsNew:RemovePersonFromQueue(per)
    local len = #self.m_personQueue
    for i = 1, len do
        if self.m_personQueue[i] == per then
            table.remove(self.m_personQueue,i)
            if per.m_queueBack then
                per.m_queueBack.m_queueFront = per.m_queueFront
            end
            if per.m_queueFront then
                per.m_queueFront.m_queueBack = per.m_queueBack
            end
            per.m_queueBack = nil
            per.m_queueFront = nil
            --per.m_idlePosition = nil
            self.m_needUpdateQueue = true
            break
        end
    end
end

---生成队伍路径点
function InteractionsNew:GenerateQueuePath()
    --AIPathNav
    local startPoint = self.m_colliderComponent.transform
    local endPoint = self.m_colliderComponent.m_queueStartPoint.transform or self.m_go.transform
    local vectorPath = UnityHelper.SearchPathByNavMesh(startPoint.position,endPoint.position)

    self.m_queuePath = {}
    local lastPos =  vectorPath[0]
    for i = 1, vectorPath.Length - 1 do
        local dir = vectorPath[i] - lastPos
        local dis = dir.magnitude
        if dis > 1 then
            --插入N个距离大于1的点.
            dir = dir.normalized
            for j = 1, dis,1 do
                lastPos = lastPos+dir*1
                table.insert(self.m_queuePath, 1, lastPos)
            end
        end
    end
end

function InteractionsNew:AddQueuePath(person)
    if not self.m_enableQueue then
        local idlePosition = self:GetFurnitureIdlePosition()
        if idlePosition then
            self:PersonGetIn(idlePosition, person)
        end
        --printf("没进入排队，self.m_enableQueue")
        return
    end

    local queueLength = #self.m_personQueue
    if queueLength == 0 then
        self.m_personQueue[1] = person
        person.m_queueFront = nil
        --如果队伍是空的，可以免进入排队状态直接去交互点
        local idlePosition = self:GetFurnitureIdlePosition()
        if idlePosition then
            if self:PersonGetIn(idlePosition) then
                return
            end
        end
    else
        person.m_queueFront = self.m_personQueue[queueLength]
        table.insert(self.m_personQueue, person)
        if person.m_queueFront then
            person.m_queueFront.m_queueBack = person
        end
    end
    -- person.m_inQueue = true
    person.m_stateMachine:ChangeState(ActorDefine.State.EmployeeQueueUpState)

    if self.m_queuePath then
        self:UpdatePerson(person)
    else
        self:GenerateQueuePath()
        self:UpdateQueue()
    end
end

function InteractionsNew:UpdatePerson(person)
    if not self.m_queuePath then
        return
    end
    self:ReSetTargetPosition(person, person:GetQueueId())
end

function InteractionsNew:UpdateQueue()
    if not self.m_queuePath then
        return
    end
    local queueMaxCount = #self.m_queuePath
    for _,per in ipairs(self.m_personQueue or {}) do
        local queueID = per:GetQueueId()
        if queueID <= queueMaxCount then --不需要移动就不要动了
            self:ReSetTargetPosition(per, queueID)
        end
    end
end

---@param per CompanyEmployeeNew
function InteractionsNew:ReSetTargetPosition(per,id)
    if not per.m_stateMachine.m_curState then
        return
    end

    local pos = self.m_queuePath[id] or self.m_queuePath[#self.m_queuePath]
    if per.m_stateMachine:IsState("EmployeeQueueUpState") then
        --已经在排队就更改位置
        per.m_stateMachine.m_curState:MoveToQueuePos(pos)
    elseif per.m_stateMachine:IsState("EmployeeGoToToiletState") then
        --进入排队
        per.m_stateMachine:ChangeState(ActorDefine.State.EmployeeQueueUpState)
        per.m_stateMachine.m_curState:MoveToQueuePos(pos)
    end
end

---@param person CompanyEmployeeNew
function InteractionsNew:PersonArriveIdlePos(person)
    if person.m_idlePosition then
        local random = math.random(1, #person.m_idlePosition.anim)
        local anim = person.m_idlePosition.anim[random]
        local setting = person.m_idlePosition.setting[random]
        person.m_randomAnim = {anim = anim, setting = setting}

        if person:HasFlag(ActorDefine.Flag.FLAG_EMPLOYEE_ON_ENTERTAINMENT) then
            self:SetPersonAnimationByAccessory(person, random)
        end

        if person.m_idlePosition.localData.id == 10051 then
            --对会议椅(10051)特殊处理,取同房间会议桌的附件
            local accessoryInfo = self:GetMeetingTableAccessoryInfo()
            person:SetPersonBonuses(person.m_randomAnim, {"pleasure", "addexp", "time"},nil ,accessoryInfo)
        else
            person:SetPersonBonuses(person.m_randomAnim, {"pleasure", "addexp", "time"})
        end

        local timeRange = self.m_colliderComponent.m_timeRange
        person.m_randomAnim.countdown = math.random(timeRange.x, timeRange.y) / 1000 + (person.m_randomAnim.time or -1)

        --person.m_stateMachine:ChangeState(setting and ActorDefine.State.EmployeeSitting or ActorDefine.State.EmployeeToiletState)
    end
end

---@param person CompanyEmployeeNew
function InteractionsNew:PersonArriveQueuePos(person)
    if self.m_personQueue[1] ~= person then
        return
    else
        local idlePosition = self:GetFurnitureIdlePosition()
        if idlePosition then
            local succ = self:PersonGetIn(idlePosition)
            if not succ then
                person.m_stateMachine:ChangeState(ActorDefine.State.EmployeeQueueUpState)
            end
        end
    end
end

---@param person CompanyEmployeeNew
function InteractionsNew:SetPersonAnimationByAccessory(person, random)
    local data = person.m_idlePosition.localData
    local config = CfgMgr.config_furnitures_levels[data.id][data.level]
    person.m_randomAnim.moodTransfer = config.pleasure or 0
    if data.accessory_info and data.accessory_info[FloorMode.F_TYPE_AUX_CONDITION] then
        local _,accessory = next(data.accessory_info[FloorMode.F_TYPE_AUX_CONDITION])
        local accessoryLevelId = accessory.lvId
        -- local accessoryId, accessoryLevel = CfgMgr.config_furnitures_levels[accessoryLevelId].furniture_id, CfgMgr.config_furnitures_levels[accessoryLevelId].level
        -- local accessoryConifg = CfgMgr.config_furnitures_levels[accessoryId][accessoryLevel]
        -- person.m_randomAnim.moodTransfer = person.m_randomAnim.moodTransfer + (accessoryConifg.pleasure or 0)
        for i, v in ipairs(self.m_localData.furnitures or {}) do
            if v.level_id == accessoryLevelId then
                local accessoryGo = self.m_sceneProcessData.furnituresGo[i]
                local accessoryAnim = self.m_furnitureAnim[accessoryGo]
                if accessoryAnim then
                    person.m_randomAnim.anim = accessoryAnim.anim[random]
                    person.m_randomAnim.setting = accessoryAnim.setting[random]
                end
                return
            end
        end
    end
end

---缓存用到的string  减少拼接字符串产生的GC
InteractionsNew.StringCache = {}

function InteractionsNew:GetStringFromCache(head,tail)
    local tails = InteractionsNew.StringCache[head]
    if not tails then
        tails = {}
        InteractionsNew.StringCache[head] = tails
    end
    local result = tails[tail]
    if not result then
        result = head..tail
        tails[tail] = result
    end
    return result
end

--endregion

return InteractionsNew